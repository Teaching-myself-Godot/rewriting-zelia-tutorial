<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Day 3 - Casting Sprites - Learning Godot by rewriting Zelia</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Day 3 - Casting Sprites";
        var mkdocs_page_input_path = "day-3.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Learning Godot by rewriting Zelia
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Tutorials</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../day-1/">Day 1 - Controlling the player</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../day-2/">Day 2 - Adding some tiles and some physics</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">Day 3 - Casting Sprites</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#learning-goals">Learning goals</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#the-steps-for-today">The steps for today</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#assign-casting-buttons">Assign casting buttons</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#fix-the-casting-sprites-for-zelia">Fix the casting sprites for Zelia</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#determine-cast-direction-via-mouse-cursor-position-and-l-stick-axis">Determine cast direction via mouse cursor position and L-stick axis</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#rearrange-the-code-in-_physics_process-a-little">Rearrange the code in _physics_process a little</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#lets-get-started">Let's get started</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#flipping-the-player-left-and-right-by-aiming">Flipping the player left and right by aiming</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#letting-zelia-stop-jumping-and-moving-on-the-x-axis-while-casting">Letting Zelia stop jumping and moving on the x-axis while casting</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#step-1-move-casting-code-up-stop-her-from-sliding">Step 1, move casting code up, stop her from sliding</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#step-2-only-jump-when-not-casting-and-not-airborne">Step 2, only jump when not casting and not airborne</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#step-3-separate-code-for-setting-initial-movement-state-from-code-updating-positions">Step 3, separate code for setting initial movement state from code updating positions.</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#draw-the-correct-casting-sprites-based-on-cast-direction">Draw the correct casting sprites based on cast direction</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#func-get_casting_sprite">func get_casting_sprite</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#extract-some-functions-for-less-messy-code">Extract some functions for less messy code</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#the-process-of-tyding-up-code">The process of tyding up code</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#spot-a-big-function-and-apply-the-steps">Spot a big function and apply the steps!</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#rinse-and-repeat">Rinse and repeat!</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#just-2-more-funcs">Just 2 more funcs!</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#all-tidied-up">All tidied up</a>
    </li>
        </ul>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#technical-debt-5">Technical debt 5</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../day-4/">Day 4 - Casting Fireballs</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../day-5/">Day 5 - Slimes, Breaking tiles, Falling Tiles, Scenery Tiles and Shaders</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Learning Godot by rewriting Zelia</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Tutorials</li>
      <li class="breadcrumb-item active">Day 3 - Casting Sprites</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="day-3-casting-sprites">Day 3 - Casting Sprites</h1>
<p>Today we're going to add Zelia's casting sprites to her script.</p>
<p>Want to start from here? </p>
<p>Clone or download the result of day 2 from <a href="https://github.com/Teaching-myself-Godot/godot-zelia/tree/after-day-2">github</a></p>
<h2 id="learning-goals">Learning goals</h2>
<ul>
<li>Determine the angle between the Zelia sprite and the mouse cursor</li>
<li>Determine the angle of the <code>L-stick</code></li>
<li>Using <code>rad_to_deg</code> to determing the correct casting sprite for aiming</li>
<li>Code refactor to tidy up code and make it more maintainable</li>
</ul>
<h2 id="the-steps-for-today">The steps for today</h2>
<ol>
<li><a href="#assign-casting-buttons">Assign casting buttons</a></li>
<li><a href="#fix-the-casting-sprites-for-zelia">Fix the casting sprites for Zelia</a> (Technical debt 1)</li>
<li><a href="#determine-cast-direction-via-mouse-cursor-position-and-l-stick-axis">Determine cast direction via mouse cursor position and L-stick axis</a></li>
<li><a href="#rearrange-the-code-in-_physics_process-a-little">Rearrange the code in <code>_physics_process</code> a little</a></li>
<li><a href="#draw-the-correct-casting-sprites-based-on-cast-direction">Draw the correct casting sprites based on cast direction</a></li>
<li><a href="#extract-some-functions-for-less-messy-code">Extract some functions for less messy code</a> (Technical debt 2)</li>
</ol>
<h2 id="assign-casting-buttons">Assign casting buttons</h2>
<p>After day 3 Zelia will cast fireballs in all directions:
- when holding gamepad button <code>B</code>, you can aim with the <code>L-stick</code>
- when holding the left mouse button, you can aim with the mouse cursor.</p>
<ol>
<li>Go to <code>Project &gt; Project Settings</code></li>
<li>Go to <code>Input Maps</code></li>
<li>Choose <code>Add New Action</code></li>
<li>Set the name to <code>Fireball button</code></li>
<li>Assign <code>Left Mouse Button</code> to <code>Fireball button</code> </li>
<li>Assign <code>Joypad Button 1</code> to <code>Fireball button</code></li>
</ol>
<p>Now to determine which of either is pressed we need to assign one to another name.</p>
<ol start="7">
<li>Choose <code>Add New Action</code></li>
<li>Set the name to <code>Left mouse button</code></li>
<li>Assign <code>Left Mouse Button</code> to your new action named <code>Left mouse button</code> </li>
</ol>
<p><img alt="Fireball buttons" src="../screenshots/fireball-buttons-added.png" /></p>
<h2 id="fix-the-casting-sprites-for-zelia">Fix the casting sprites for Zelia</h2>
<p>On day 1 we added one <code>SpriteFrames</code> entry for all casting images. </p>
<p>We should have made an entry per image to cover all her angles of casting:</p>
<ol>
<li>Go to <code>FileSystem &gt; res:// &gt; player &gt; player.tscn</code></li>
<li>Go to <code>Scene &gt; Player &gt; AnimatedSprite2D</code></li>
<li>On the bottom pane choose <code>casting</code></li>
<li>Rename it to <code>casting_down</code> (click on it a second time)</li>
<li>Select the image casting forward </li>
<li>Press <code>Ctrl-C</code> to copy it</li>
<li>Add a new <code>Animation</code> named <code>casting_forward</code></li>
<li>Click on the preview window</li>
<li>Select it and press <code>Ctrl-V</code> to paste the image of Zelia casting forward</li>
<li>Repeat this process until you have 4 entries: <code>casting_up</code>, <code>casting_diag_up</code>, <code>casting_forward</code> and <code>casting_down</code></li>
<li>Remove the images <em>not</em> casting down from the <code>casting_down</code> animation:</li>
</ol>
<p><img alt="casting_diag_up" src="../screenshots/casting_diag_up.png" />
<img alt="casting_down" src="../screenshots/casting_down.png" />
<img alt="casting_forward" src="../screenshots/casting_forward.png" />
<img alt="casting_up" src="../screenshots/casting_up.png" /></p>
<p><strong>Note</strong>: the image called <code>casting_down</code> will also be used for casting down diagonally. </p>
<p>(Her arms look really silly when pointing directly down)</p>
<h2 id="determine-cast-direction-via-mouse-cursor-position-and-l-stick-axis">Determine cast direction via mouse cursor position and L-stick axis</h2>
<p>First let's write some code to see if we can set the angle of casting when one of the <code>Fireball button</code>s is pressed.</p>
<p>Later on we'll pick the correct sprite, based on her angle of casting</p>
<p>Go to <code>FileSystem &gt; player &gt; player.gd</code> to edit the script.</p>
<ol>
<li>Add a movement state for casting:</li>
</ol>
<pre><code class="language-gdscript">enum MovementState { IDLE, RUNNING, AIRBORNE, CASTING }
</code></pre>
<ol start="2">
<li>Add a property for the direction of casting</li>
</ol>
<pre><code class="language-gdscript">@export var cast_angle : float
</code></pre>
<ol start="3">
<li>In the <code>_physics_process</code>  set <code>cast_angle</code> and <code>movement_state</code> right above the jump code</li>
</ol>
<pre><code class="language-gdscript">    if Input.is_action_pressed(&quot;Fireball button&quot;):
        movement_state = MovementState.CASTING
        # base the angle of casting on the position of the mouse
        # relative to Zelia or on the L-stick
        if Input.is_action_pressed(&quot;Left mouse button&quot;):
            cast_angle = (get_global_mouse_position() - position).normalized().angle()
        else:
            cast_angle = Vector2(Input.get_joy_axis(0, JOY_AXIS_LEFT_X), Input.get_joy_axis(0, JOY_AXIS_LEFT_Y)).normalized().angle()

    # Handle Jump, only when on the floor
</code></pre>
<ol start="4">
<li>Test via remote debugging</li>
</ol>
<p>This time we will monitor the exported property <code>cast_angle</code>. </p>
<p>If you forgot how, I documented it on day 1. Remote debug <a href="../day-1/#test-run">see</a></p>
<ol>
<li>Run the main scene with <code>F5</code> to see if the <code>Cast Angle</code> property changes when either:</li>
<li>Pick <code>Remote</code></li>
<li>Go to <code>root &gt; World &gt; Player</code></li>
<li>Look at the inspector</li>
</ol>
<p>Check and see if the <code>Cast Angle</code> value changes when you:
- left-click the mouse somewhere in the game window
- press <code>B</code> and move the <code>L-stick</code> (the player wil slide around in looking <code>idle</code> right now)</p>
<p><img alt="remote debug cast angle" src="../screenshots/remote_debug_cast_angle.png" /></p>
<h2 id="rearrange-the-code-in-_physics_process-a-little">Rearrange the code in <code>_physics_process</code> a little</h2>
<p><strong>NOTE</strong> This section will rearrange code to look like this, in case you get stuck: </p>
<p><a href="https://github.com/Teaching-myself-Godot/godot-zelia/blob/letting-zelia-stop-x-on-cast/player/player.gd">player.gd</a></p>
<p>You could also download it and <a href="#draw-the-correct-casting-sprites-based-on-cast-direction">skip to the next section</a>.</p>
<h3 id="lets-get-started">Let's get started</h3>
<p>We need to rearrange our code in the <code>_physics_process</code> a little in order to achieve 2 things:</p>
<ol>
<li>Let Zelia flip orientation based on her casting angle</li>
<li>Let Zelia stop jumping and moving on the x-axis while casting</li>
</ol>
<h3 id="flipping-the-player-left-and-right-by-aiming">Flipping the player left and right by aiming</h3>
<p>Extend the code in the <code>if</code>-block we just created for setting the <code>cast_angle</code> to include setting the <code>orientation</code>-property correctly.</p>
<pre><code class="language-gdscript">    if Input.is_action_pressed(&quot;Fireball button&quot;):

        ## ... movement_state and cast_angle are still set here

        # base her orientation on the angle of casting as well
        if cast_angle &gt; -(PI * 0.5) and cast_angle &lt; PI * 0.5:
            orientation = Orientation.RIGHT
        else:
            orientation = Orientation.LEFT
</code></pre>
<p>Test using <code>F5</code>: when clicking with the mouse left of her she should now flip to look left.</p>
<h3 id="letting-zelia-stop-jumping-and-moving-on-the-x-axis-while-casting">Letting Zelia stop jumping and moving on the x-axis while casting</h3>
<p>When she's casting she should not slide sideways.</p>
<p>We don't want her to be able to move horizontally while casting in the air (which would make her way too powerful).</p>
<h4 id="step-1-move-casting-code-up-stop-her-from-sliding">Step 1, move casting code up, stop her from sliding</h4>
<ol>
<li>First move your entire <code>if Input.is_action_pressed("Fireball button")</code>-block all the way up to below <code>velocity.y += gravity * delta</code>.</li>
<li>Change <code>if movement_state == MovementState.AIRBORNE</code> into <code>elif movement_state == MovementState.AIRBORNE</code></li>
</ol>
<pre><code class="language-gdscript">    if Input.is_action_pressed(&quot;Fireball button&quot;):
        movement_state = MovementState.CASTING
        # base the angle of casting on the position of the mouse
        # relative to Zelia or on the L-stick
        if Input.is_action_pressed(&quot;Left mouse button&quot;):
            cast_angle = (get_global_mouse_position() - position).normalized().angle()
        else:
            cast_angle = Vector2(Input.get_joy_axis(0, JOY_AXIS_LEFT_X), Input.get_joy_axis(0, JOY_AXIS_LEFT_Y)).normalized().angle()
        # base her orientation on the angle of casting as well
        if cast_angle &gt; -(PI * 0.5) and cast_angle &lt; PI * 0.5:
            orientation = Orientation.RIGHT
        else:
            orientation = Orientation.LEFT
    elif movement_state == MovementState.AIRBORNE:
</code></pre>
<p>This stops her from sliding or moving around while in the air.</p>
<h4 id="step-2-only-jump-when-not-casting-and-not-airborne">Step 2, only jump when not casting <em>and</em> not airborne</h4>
<p>She can still jump while casting now, let's fix that.</p>
<p>Indent the <code>if Input.is_action_just_pressed("Jump") and is_on_floor()</code> to make it part of the <code>else</code>-case matching not casting and not being airborne</p>
<pre><code class="language-gdscript">    else:
        # Else we are not airborne right now
        if Input.is_action_pressed(&quot;Run right&quot;):
            # so we run right when run right is pressed
            orientation = Orientation.RIGHT
            movement_state = MovementState.RUNNING
            velocity.x = speed
        elif Input.is_action_pressed(&quot;Run left&quot;):
            # .. and left ...
            orientation = Orientation.LEFT
            movement_state = MovementState.RUNNING
            velocity.x = -speed
        else:
            # and stand idle if no x-movement button is pressed
            velocity.x = 0
            movement_state = MovementState.IDLE  

## This is new
        # Handle Jump, only when on the floor
        if Input.is_action_just_pressed(&quot;Jump&quot;):
            $JumpSound.play()
            movement_state = MovementState.AIRBORNE
            velocity.y = jump_speed
</code></pre>
<p>That stopped her from jumping while casting</p>
<h4 id="step-3-separate-code-for-setting-initial-movement-state-from-code-updating-positions">Step 3, separate code for setting initial movement state from code updating positions.</h4>
<p>This step will have no <em>functional</em> effect, but it will prepare us for our "readable code refactor" that comes next.</p>
<p><strong>First</strong> create this new <code>if-block</code> just under <code>velocity.y += gravity * delta</code>:</p>
<pre><code class="language-gdscript">    # Set initial movement state
    if Input.is_action_pressed(&quot;Fireball button&quot;):
        movement_state = MovementState.CASTING
        # base the angle of casting on the position of the mouse
        # relative to Zelia or on the L-stick
        if Input.is_action_pressed(&quot;Left mouse button&quot;):
            cast_angle = (get_global_mouse_position() - position).normalized().angle()
        else:
            cast_angle = Vector2(Input.get_joy_axis(0, JOY_AXIS_LEFT_X), Input.get_joy_axis(0, JOY_AXIS_LEFT_Y)).normalized().angle()
    elif is_on_floor():
        movement_state = MovementState.IDLE
    else:
        movement_state = MovementState.AIRBORNE
</code></pre>
<p><strong>Second</strong> Replace the old <code>if Input.is_action_pressed("Fireball button")</code>-block with this code:</p>
<pre><code class="language-gdscript">    # Update movement state, velocity and orientation based on the combo of
    # her current movement state and environmental factors
    if movement_state == MovementState.CASTING:
        # She cannot run or move on x-axis in the air while casting
        velocity.x = 0
        # base her orientation on the angle of casting as well
        if cast_angle &gt; -(PI * 0.5) and cast_angle &lt; PI * 0.5:
            orientation = Orientation.RIGHT
        else:
            orientation = Orientation.LEFT
    elif movement_state == MovementState.AIRBORNE:
</code></pre>
<p>Your script should now look like this:</p>
<p><a href="https://github.com/Teaching-myself-Godot/godot-zelia/blob/letting-zelia-stop-x-on-cast/player/player.gd">player.gd  (tag = letting-zelia-stop-x-on-cast)</a></p>
<h2 id="draw-the-correct-casting-sprites-based-on-cast-direction">Draw the correct casting sprites based on cast direction</h2>
<p>Let's make a well-named function to choose the correct sprite name to draw:</p>
<h3 id="func-get_casting_sprite"><code>func get_casting_sprite</code></h3>
<pre><code class="language-gdscript">## Determine the casting sprite name based on decimal degrees
func get_casting_sprite(deg) -&gt; String:
    var casting_left  = (deg &gt; 120 and deg &lt; 180) or (deg &gt; -180 and deg &lt; -120)
    var casting_right = deg &gt; -60  and deg &lt; 60
    var casting_up    = deg &gt; -140 and deg &lt; -20
    var casting_down  = deg &gt; 30   and deg &lt; 150

    if casting_up and (casting_right or casting_left):
        return &quot;casting_diag_up&quot;
    elif casting_down and (casting_right or casting_left):
        return &quot;casting_down&quot;
    elif casting_up:
        return &quot;casting_up&quot;
    elif casting_down:
        return &quot;casting_down&quot;
    else:
        return &quot;casting_forward&quot;
</code></pre>
<p>As you can see, this function expects the cast_angle to be passed as <code>decimal degrees</code> in stead of <code>radians</code>.</p>
<p>This makes the code a little more self-documenting, at the cost of some minimal performance.</p>
<p>Now let's also add the case for <code>MovementState.CASTING</code> to our <code>match</code>-statement:</p>
<pre><code class="language-gdscript">    # Determine sprite based on movement state
    match (movement_state):
        MovementState.RUNNING:
            $AnimatedSprite2D.animation = &quot;running&quot;
        # This was added
        MovementState.AIRBORNE:
            $AnimatedSprite2D.animation = &quot;jumping&quot;
        MovementState.CASTING:
            # when casting invoke get_casting_sprite to set the correct 
            # animation name
            $AnimatedSprite2D.animation = get_casting_sprite(rad_to_deg(cast_angle))
        _: # MovementState.IDLE
            $AnimatedSprite2D.animation = &quot;idle&quot;
</code></pre>
<p>Note the <code>rad_to_deg</code> there.</p>
<h2 id="extract-some-functions-for-less-messy-code">Extract some functions for less messy code</h2>
<p>Now it's really time to fix <a href="../day-1/#technical-debt-2">Technical debt 2</a>, because the debt became deeper.</p>
<p><strong>NOTE</strong>: if you're already familiar with code refactors or want/need a reference, you can download the final code of today here:
- <a href="https://github.com/Teaching-myself-Godot/godot-zelia/blob/164027e6ed74a70c1222778ebcd8dffba24ec416/player/player.gd">player.gd</a></p>
<p>And if you're already quite familiar with these types of refactor, here's a skip link to day 4:
- <a href="../day-4/">Day 4 - Casting fireballs</a></p>
<h3 id="the-process-of-tyding-up-code">The process of tyding up code</h3>
<p>Now there must be a pattern or best practice name for this, but here's how it goes.</p>
<p>Spot a function with a lot of code in the function body and do:
1. For each bit of code needs comments to explain what it does, create a function named after the comments.
2. For each block of code handling a case in an if-block write a function that says what it handles
3. For each line of code longer than your coding viewport, write functions to shorten that line
4. For each complex boolean evaluation write a function with a name that says what it does
5. For each code repetition write a function to be reused</p>
<p>... etcetera.</p>
<p>This refactor only applied step <code>1</code>, <code>2</code> and <code>3</code></p>
<h4 id="spot-a-big-function-and-apply-the-steps">Spot a big function and apply the steps!</h4>
<p>Let's rewrite the above <a href="#rearrange-the-code-in-_physics_process-a-little">code</a> again.</p>
<p>We spot that <code>_physics_process</code> is now almost 100 lines long!</p>
<p>Step <code>1</code> - code that needs comments:</p>
<pre><code class="language-gdscript">    # Handle casting
    if Input.is_action_pressed(&quot;Fireball button&quot;):
        movement_state = MovementState.CASTING
        # base the angle of casting on the position of the mouse
        # relative to Zelia or on the L-stick
        if Input.is_action_pressed(&quot;Left mouse button&quot;):
            cast_angle = (get_global_mouse_position() - position).normalized().angle()
        else:
            cast_angle = Vector2(Input.get_joy_axis(0, JOY_AXIS_LEFT_X), Input.get_joy_axis(0, JOY_AXIS_LEFT_Y)).normalized().angle()
    elif is_on_floor():
        movement_state = MovementState.IDLE
    else:
        movement_state = MovementState.AIRBORNE
</code></pre>
<p>Is moved to a separate function named <code>set_movement_state</code>.</p>
<pre><code class="language-gdscript"># Set initial movement state
func set_movement_state():
    if Input.is_action_pressed(&quot;Fireball button&quot;):
        movement_state = MovementState.CASTING
        # base the angle of casting on the position of the mouse
        # relative to Zelia or on the L-stick
        if Input.is_action_pressed(&quot;Left mouse button&quot;):
            cast_angle = (get_global_mouse_position() - position).normalized().angle()
        else:
            cast_angle = Vector2(Input.get_joy_axis(0, JOY_AXIS_LEFT_X), Input.get_joy_axis(0, JOY_AXIS_LEFT_Y)).normalized().angle()
    elif is_on_floor():
        movement_state = MovementState.IDLE
    else:
        movement_state = MovementState.AIRBORNE
</code></pre>
<p>Step <code>1</code> can be applied again to this new function:</p>
<pre><code class="language-gdscript"># base the angle of casting on the position of the mouse relative to Zelia
func set_cast_angle():
    if Input.is_action_pressed(&quot;Left mouse button&quot;):
        cast_angle = (get_global_mouse_position() - position).normalized().angle()
    else:
        cast_angle = Vector2(Input.get_joy_axis(0, JOY_AXIS_LEFT_X), Input.get_joy_axis(0, JOY_AXIS_LEFT_Y)).normalized().angle()

# Set initial movement state
func set_movement_state():
    if Input.is_action_pressed(&quot;Fireball button&quot;):
        movement_state = MovementState.CASTING
        set_cast_angle()
    elif is_on_floor():
        movement_state = MovementState.IDLE
    else:
        movement_state = MovementState.AIRBORNE
</code></pre>
<p>Now both step <code>2</code> and <code>3</code> still apply to this new function:</p>
<pre><code class="language-gdscript"># Vector of L-stick
func get_l_stick_axis_vec() -&gt; Vector2:
    return Vector2(
        Input.get_joy_axis(0, JOY_AXIS_LEFT_X), 
        Input.get_joy_axis(0, JOY_AXIS_LEFT_Y)
    )

# Vector from player to mouse position
func get_mouse_vec_to_player() -&gt; Vector2:
    return get_global_mouse_position() - position

# base the angle of casting on the position of the mouse relative to Zelia
func set_cast_angle():
    if Input.is_action_pressed(&quot;Left mouse button&quot;):
        cast_angle = get_mouse_vec_to_player().normalized().angle()
    else:
        cast_angle = get_l_stick_axis_vec().normalized().angle()
</code></pre>
<h4 id="rinse-and-repeat">Rinse and repeat!</h4>
<p>Now we spot this elaborate comment: </p>
<p><em>"Update movement state, velocity and orientation based on the combo of her current movement state and environmental factors"</em></p>
<p>Applying the refactor steps listed previously do:
1. Create a function <code>handle_movement_state</code>
2. Cut+paste all the code under the long comment up to above the <code>match</code> call into <code>handle_movement_state</code>
3. Call <code>handle_movement_state()</code> after <code>set_movement_state()</code>
4. Create a func <code>handle_casting</code>
5. Cut+paste all the code within the block <code>if movement_state == MovementState.CASTING:</code> into it
6. Call <code>handle_casting()</code> in this if block
7. Do the same for <code>handle_airborne()</code> under <code>elif movement_state == MovementState.AIRBORNE:</code>
8. And make 2 functions to be called under <code>else:</code> - <code>handle_running()</code> and <code>handle_jumping()</code></p>
<p>Your final func <code>handle_movement_state()</code> should now look like this.</p>
<pre><code class="language-gdscript"># Main movement state handler entry point
func handle_movement_state():
    if movement_state == MovementState.CASTING:
        handle_casting()
    elif movement_state == MovementState.AIRBORNE:
        handle_airborne()
    else:
        handle_running()
        handle_jumping()
</code></pre>
<h4 id="just-2-more-funcs">Just 2 more funcs!</h4>
<ol>
<li>Create the function <code>set_current_sprite</code></li>
<li>Put the entire block of <code>match (movement_state):</code> in it</li>
<li>Invoke it under <code>handle_movement_state()</code></li>
</ol>
<p>And :</p>
<ol>
<li>Create the function <code>flip_current_sprite</code></li>
<li>Put the entire if-else block of <code>if orientation == Orientation.LEFT:</code> in it</li>
<li>Invoke it under <code>set_current_sprite()</code></li>
</ol>
<h4 id="all-tidied-up">All tidied up</h4>
<p>Your <code>_physics_process</code> should now look like this:</p>
<pre><code class="language-gdscript"># Changed _process to _physics_process
func _physics_process(delta):
    # Apply the gravity.
    velocity.y += gravity * delta

    # Set, and handle movement state 
    set_movement_state()
    handle_movement_state()

    # Set the correct sprite based on movement state
    set_current_sprite()

    # Determine sprite-flip based on orientation
    flip_current_sprite()

    # Apply 2d physics engine's movement 
    move_and_slide()
</code></pre>
<p>And everything should still work.</p>
<p>Your entire <code>player.gd</code> script should look like this:</p>
<p><a href="https://github.com/Teaching-myself-Godot/godot-zelia/blob/164027e6ed74a70c1222778ebcd8dffba24ec416/player/player.gd"><code>player.gd</code></a> - on github commit: <em>"use my own tutorial for day-3 part 1."</em></p>
<h2 id="technical-debt-5">Technical debt 5</h2>
<p>Two observation on remaining technical debt:</p>
<ul>
<li>Our comments probably do not conform to documentation guidelines</li>
<li>Some coding conventions might not comply either</li>
</ul>
<p>Let's park that and go right on ahead to:</p>
<p><a href="../day-4/">Day 4 - Casting Fireballs</a></p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../day-2/" class="btn btn-neutral float-left" title="Day 2 - Adding some tiles and some physics"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../day-4/" class="btn btn-neutral float-right" title="Day 4 - Casting Fireballs">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../day-2/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../day-4/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>

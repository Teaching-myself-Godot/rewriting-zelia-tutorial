{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Learning Godot by rewriting Zelia Start right now! Day 1 - Controlling the Player Day 2 - Adding some tiles and some physics Day 3 - Casting Sprites Day 4 - Casting Fireballs Day 5 - Slimes, Breaking tiles, Falling Tiles, Scenery Tiles and Shaders Browse topics Generating textures dynamically in code Singleton auto-loaded resources Autotiles in godot 4.1.1 Refactoring big functions Basic platformer 2D physics 2D shaders Interactive TileMap Recipes Sneak preview You can see a sneak preview of my progress on the itch.io draft via a (not so) secret url: Sneak Preview Back story Last year I collaborated with my son on creating a game from scratch. We soon discovered that a game needs a lot of content and ended up one year later with a lot of level editor and very little game. You can download the windows installer on itch.io The code I will not be open sourcing the original game, but I will probably be showing a lot of typescript and python snippets from it in these tutorials along the way. The code for this tutorial will be living in it's sister repo on github . Fair warning Although I am a software developer with about 20 years of experience, over half of that professionally, I'm totally new to godot . The good news is that we will both be having the beginner's mindset and you can contribute if you like! We'll discover how that goes together as well. Let's dive right in. I will be documenting my work in numbered days, some days we'll get a lot done. On others, well you know how that goes. Day 1 - Controlling the Player Day 2 - Adding some tiles and some physics Day 3 - Casting Sprites Day 4 - Casting Fireballs Day 5 - Slimes, Breaking tiles, Falling Tiles, Scenery Tiles and Shaders Things I read up on This section contains links I read up on but haven't used (yet) / might not use at all for this project. Things we will need Using TileMaps Terrain Autotiling and Alternative Tiles ~ Godot 4 Tutorial for Beginners CharacterBody2D RigidBody2D Singletons (Autoload)\u00b6 Things we probably won't need, but would like to How to use Godot's AStar2D for path finding","title":"Home"},{"location":"#learning-godot-by-rewriting-zelia","text":"","title":"Learning Godot by rewriting Zelia"},{"location":"#start-right-now","text":"Day 1 - Controlling the Player Day 2 - Adding some tiles and some physics Day 3 - Casting Sprites Day 4 - Casting Fireballs Day 5 - Slimes, Breaking tiles, Falling Tiles, Scenery Tiles and Shaders","title":"Start right now!"},{"location":"#browse-topics","text":"Generating textures dynamically in code Singleton auto-loaded resources Autotiles in godot 4.1.1 Refactoring big functions Basic platformer 2D physics 2D shaders Interactive TileMap Recipes","title":"Browse topics"},{"location":"#sneak-preview","text":"You can see a sneak preview of my progress on the itch.io draft via a (not so) secret url: Sneak Preview","title":"Sneak preview"},{"location":"#back-story","text":"Last year I collaborated with my son on creating a game from scratch. We soon discovered that a game needs a lot of content and ended up one year later with a lot of level editor and very little game. You can download the windows installer on itch.io","title":"Back story"},{"location":"#the-code","text":"I will not be open sourcing the original game, but I will probably be showing a lot of typescript and python snippets from it in these tutorials along the way. The code for this tutorial will be living in it's sister repo on github .","title":"The code"},{"location":"#fair-warning","text":"Although I am a software developer with about 20 years of experience, over half of that professionally, I'm totally new to godot . The good news is that we will both be having the beginner's mindset and you can contribute if you like! We'll discover how that goes together as well.","title":"Fair warning"},{"location":"#lets-dive-right-in","text":"I will be documenting my work in numbered days, some days we'll get a lot done. On others, well you know how that goes. Day 1 - Controlling the Player Day 2 - Adding some tiles and some physics Day 3 - Casting Sprites Day 4 - Casting Fireballs Day 5 - Slimes, Breaking tiles, Falling Tiles, Scenery Tiles and Shaders","title":"Let's dive right in."},{"location":"#things-i-read-up-on","text":"This section contains links I read up on but haven't used (yet) / might not use at all for this project.","title":"Things I read up on"},{"location":"#things-we-will-need","text":"Using TileMaps Terrain Autotiling and Alternative Tiles ~ Godot 4 Tutorial for Beginners CharacterBody2D RigidBody2D Singletons (Autoload)\u00b6","title":"Things we will need"},{"location":"#things-we-probably-wont-need-but-would-like-to","text":"How to use Godot's AStar2D for path finding","title":"Things we probably won't need, but would like to"},{"location":"day-1/","text":"Day 1 - Controlling the player So before we start a day: please look at the prerequisites and make sure you are familiar with all the links referred to. Prerequisites I started learning godot 4.1.1 yesterday. What I did first is make the example 2D game there, after carefully reading up on the key concepts: Key concepts Step by Step Your first 2D game In case you, like me, are working in windows and have 2 old monitors connected via laptop docking station: my godot engine crashed while moving it to an external monitor. Apparently, it's a known issue also here . A new project Let's start a new project. Because Zelia once started out as an HTML5 webgame it might work well in the web again. Also I want to be able to compile to as many platforms as possible this time, so let's pick the Compatibility renderer: Importing the player assets Because Zelia has become a pretty big project we should pay attention to directory structure early on. Let's make a subdir in the root folder named player with another subdir named images . You can download her png files from assets/zelia-player.zip Your FileSystem tab should now look like this: Zelia also has a jump sound. Let's create a sounds dir for it. Here is her jump-sound.wav : Player Node setup For this bit we'll be guided by the instructions in Your first 2D game . If you're missing details on how to execute the next steps, please refer to it. Add an Area2D node and rename it to Player . Save the player.tscn file in res://player/player.tscn Make Player 's child nodes not selectable Add an AnimatedSprite2D child node with a SpriteFrames resource Click SpriteFrames again to open the Animations panel. Setting up the animations We need the following animation names in the list: - casting - dying - forward - idle - jumping - running The asset files you downloaded give a good filename hint as to where they belong, but I will list them for you anyway. Add the images like so: casting: cast-1.png up to cast-4.png dying: faint-1 up to faint-8.png forward: forward.png idle: stand-1.png jumping: jump.png running: run-1.png up to run-5.png AND run-4.png down to run-2.png Higher framerate When testing the animation for running I noticed that it did not look as smooth as I was used to. Matching the original game let's change the framerate from 5 to 15 for dying and running : Technical debt 1 In the original game casting was not - strictly speaking - an animation, but a set of casting orientations based on an angle. We will probably have to fix that later. Setting up the screen Zelia looks so small! That makes perfect sense because she's only about 30 pixels tall. The original game resolution was fullscreen and matched the aspect ratio of your active monitor to make the game 320px wide. After stumbling my own way through the settings, I looked up this guide on resolutions . Although I would have preferred the outcome to look like this: What I managed to achieve in godot by myself was blurry. However, this reddit thread came to the rescue to help me end up with this: The final resizable window setup I'm happy with Open Project > Project Settings Go to Display > Window Set Viewport Width to 320 And Viewport Height to 180 Make sure Mode is set to Windowed And that Resizable is checked to On Set the Stretch mode to canvas_items And the Aspect to keep Then open Render > Textures > Canvas Textures And change Filter to Nearest Add a hitbox So the original Zelia had pixel perfect collisions. I wrote everything myself, so it was quite a battery hog in modern machines and a performance killer in older machines. However, I mainly did that to avoid having to draw hitboxes and doing polygon based collision math myself. If we want pixel perfect collision again, we'd probably follow this recipe on stackoverflow . For now, let's make do with a nice pill shape just like in the guide . Create another child node for Player of the type CollisionShape2D . Choose CapsuleShape2D in the inspector tab next to Shape 'Ungroup' the children of Player to make the CollisionShape2D selectable Align the box like in the screenshot below And 'group' them again. Save everything and test the current scene with F6 (make sure Zelia's in the viewport). Adding controls The original game was written for a gamepad and tested with this (tr|d)usty controller: Keyboard and mouse were added later and work quite differently. So let's first create some dedicated inputs for running and jumping and see if we can fix the casting+aiming mechanic later. Input Map Open Project > Project Settings > Input Map . Add these new Actions : Run right Run left Jump Assign these keys to Run right : Keyboard 'D' - D (Physical) Keyboard Right arrow - Right (Physical) Joypad Axis 0 ( Left Stick Right , Joystick 0 Right - All Devices ) Joypad Button 14 ( D-pad Right - All Devices ) Assign these keys to Run left : Keyboard 'A' - A (Physical) Keyboard Left arrow - Left (Physical) Joypad Axis 0 ( Left Stick Left , Joystick 0 Left - All Devices ) Joypad Button 13 ( D-pad Left - All Devices ) And assign these keys to Jump : Keyboard 'W' - W (Physical) Keyboard Up arrow - Up (Physical) Joypad Button 0 - ( Buttom Action , Sony Cross , Xbox A , Ninendo B ) Player script Finally, let's code some stuff, taking guidance from the official guide . Attach a script to the Player -node and save it in res://player/player.gd So in the original game there were some movement states I would like to keep using to make our rewrite easier: from enum import Enum class Orientation ( Enum ): LEFT = 1 RIGHT = 2 NONE = 3 UP = 4 DOWN = 5 class MovementState ( Enum ): IDLE = 1 RUNNING = 2 AIRBORNE = 3 JUMPING = 4 DYING = 5 CASTING = 6 FACING_FORWARD = 7 HOLDING_ITEM = 8 class CastDirection ( Enum ): DIAG_DOWN = 1 FORWARD = 2 DIAG_UP = 3 UP = 4 DOWN = 5 Let's read up on how to port these python style enums to gdscript. That looks nice and clean, let's define some inside our player.gd script for now. Let's assign them to some properties in the _ready() func. extends Area2D enum Orientation { LEFT , RIGHT } enum MovementState { IDLE , RUNNING , AIRBORNE } # We will want to debug these states, let's export them as well @ export var movement_state : int @ export var orientation : int func _ready (): movement_state = MovementState . IDLE orientation = Orientation . RIGHT func _process ( delta ): pass Test run Run the current scene to test our property assignments. To debug exported properties while running, go to the node tree window and pick Remote in stead of Local : Then click the root -node first and then the Player -node. The Inspector tab for Player should now show: You can even change the property values through this interface! Implement running animations So let's now write some body for the _process() func. Let's first write tests for the Run right and Run left actions to set the movement func _process ( delta ): if Input . is_action_pressed ( \"Run right\" ): orientation = Orientation . RIGHT movement_state = MovementState . RUNNING elif Input . is_action_pressed ( \"Run left\" ): orientation = Orientation . LEFT movement_state = MovementState . RUNNING else : movement_state = MovementState . IDLE To test out whether our state changes work we run the current scene and open the Remote inspector for player. (Remember: click the root -node first and then the Player -node). I noticed a slight delay in the inspector, but I'm guessing that's due to it being on a lower priority thread. Picking the right animations based on states Let's reread the guide on changing the animations. Add the following code at the bottom of the _process func: match ( movement_state ): MovementState . RUNNING : $ AnimatedSprite2D . animation = \"running\" _ : # MovementState.IDLE $ AnimatedSprite2D . animation = \"idle\" if orientation == Orientation . LEFT : $ AnimatedSprite2D . flip_h = true else : $ AnimatedSprite2D . flip_h = false And make sure our AnimatedSprite2D node starts playing in func _ready . func _ready (): movement_state = MovementState . IDLE orientation = Orientation . RIGHT $ AnimatedSprite2D . play () Test the current scene and if all is well our little Zelia is up and running! (pun intended) Implementing the jump Ok so now we want her to jump! This is harder than it seems. It's not just a matter of if jump-is-pressed then draw jump : we are missing some environmental factors. Let's first define what we know about how jumping works. Test if the jump button was just pressed Input.is_action_just_pressed(\"Jump\") Player receives some negative y-acceleration Player spends some time in the air (i.e. is not touching a floor) Gravity (some positive y-acceleration) pulls the player back down. Seems like it would be a smart move to change the Player -node into a RigidBody2D at some stage. However, for now we just want to have some direct feedback from our inputs so let's mock some air time: Mock airtime node Create a new Timer node as a child node for Player and call it MockAirTimer ... or if you're deadset on it MockAirborneTimeTimer . :-) Let the Wait Time property remain at 1s and mark it as One Shot . Starting the MockAirTimer when the jump button was pressed Change the _process func to match this snippet; changes and additions are under the comments. func _process ( delta ): # If user wants to jump, start the MockAirTimer and change the movement state to airborne if Input . is_action_just_pressed ( \"Jump\" ) and movement_state != MovementState . AIRBORNE : $ MockAirTimer . start () movement_state = MovementState . AIRBORNE if Input . is_action_pressed ( \"Run right\" ): orientation = Orientation . RIGHT # Only change movement state to running if not airborne movement_state = MovementState . RUNNING if movement_state != MovementState . AIRBORNE else MovementState . AIRBORNE elif Input . is_action_pressed ( \"Run left\" ): orientation = Orientation . LEFT # Only change movement state to running if not airborne movement_state = MovementState . RUNNING if movement_state != MovementState . AIRBORNE else MovementState . AIRBORNE else : # Only change movement state to idle if not airborne movement_state = MovementState . IDLE if movement_state != MovementState . AIRBORNE else MovementState . AIRBORNE match ( movement_state ): MovementState . RUNNING : $ AnimatedSprite2D . animation = \"running\" # This was added MovementState . AIRBORNE : $ AnimatedSprite2D . animation = \"jumping\" _ : # MovementState.IDLE $ AnimatedSprite2D . animation = \"idle\" if orientation == Orientation . LEFT : $ AnimatedSprite2D . flip_h = true else : $ AnimatedSprite2D . flip_h = false Listening to the MockAirTimer timeout If we let her jump now she will remain airborne forever. Let's not forget to add a listener to the MockAirTimer . Select the MockAirTimer -node in the node tree view and open the Node tab next to the Inspector tab. Double-click timeout() to open the Connect a Signal dialog: Leave all the defaults in place and click Connect Handle the timeout We now end up with the listener func _on_mock_air_timer_timeout to implement like this: func _on_mock_air_timer_timeout (): movement_state = MovementState . IDLE Run the player scene to test out the jump. Tweaking the timings Personally I think one second of air time is a little to long, so let's change it to 0.7s - not too long as to seem unnatural, yet long enough for her to change direction in the air. Jump sound Before we round up let's also add in the jump sound. Create a new child node for Player of type AudioStreamPlayer and call it JumpSound . Open up the Inspector and next to Stream use Quick load and pick jump-sound.wav from our resources dir. Then add this new line of code in _process : if Input . is_action_just_pressed ( \"Jump\" ) and movement_state != MovementState . AIRBORNE : $ JumpSound . play () # the new line Technical debt 2 The code is starting to look a little messy already, so we might want refactor at this point. No worries, we'll revisit this code often. Wrap up Well that wraps up our day. I hope you enjoyed it as much as I did! Our next day will introduce some tiles and some movement: Day 2 - Adding some tiles and some physics Maybe we can even try out that RigidBody2D at some stage!","title":"Day 1 - Controlling the player"},{"location":"day-1/#day-1-controlling-the-player","text":"So before we start a day: please look at the prerequisites and make sure you are familiar with all the links referred to.","title":"Day 1 - Controlling the player"},{"location":"day-1/#prerequisites","text":"I started learning godot 4.1.1 yesterday. What I did first is make the example 2D game there, after carefully reading up on the key concepts: Key concepts Step by Step Your first 2D game In case you, like me, are working in windows and have 2 old monitors connected via laptop docking station: my godot engine crashed while moving it to an external monitor. Apparently, it's a known issue also here .","title":"Prerequisites"},{"location":"day-1/#a-new-project","text":"Let's start a new project. Because Zelia once started out as an HTML5 webgame it might work well in the web again. Also I want to be able to compile to as many platforms as possible this time, so let's pick the Compatibility renderer:","title":"A new project"},{"location":"day-1/#importing-the-player-assets","text":"Because Zelia has become a pretty big project we should pay attention to directory structure early on. Let's make a subdir in the root folder named player with another subdir named images . You can download her png files from assets/zelia-player.zip Your FileSystem tab should now look like this: Zelia also has a jump sound. Let's create a sounds dir for it. Here is her jump-sound.wav :","title":"Importing the player assets"},{"location":"day-1/#player-node-setup","text":"For this bit we'll be guided by the instructions in Your first 2D game . If you're missing details on how to execute the next steps, please refer to it. Add an Area2D node and rename it to Player . Save the player.tscn file in res://player/player.tscn Make Player 's child nodes not selectable Add an AnimatedSprite2D child node with a SpriteFrames resource Click SpriteFrames again to open the Animations panel.","title":"Player Node setup"},{"location":"day-1/#setting-up-the-animations","text":"We need the following animation names in the list: - casting - dying - forward - idle - jumping - running The asset files you downloaded give a good filename hint as to where they belong, but I will list them for you anyway. Add the images like so: casting: cast-1.png up to cast-4.png dying: faint-1 up to faint-8.png forward: forward.png idle: stand-1.png jumping: jump.png running: run-1.png up to run-5.png AND run-4.png down to run-2.png","title":"Setting up the animations"},{"location":"day-1/#higher-framerate","text":"When testing the animation for running I noticed that it did not look as smooth as I was used to. Matching the original game let's change the framerate from 5 to 15 for dying and running :","title":"Higher framerate"},{"location":"day-1/#technical-debt-1","text":"In the original game casting was not - strictly speaking - an animation, but a set of casting orientations based on an angle. We will probably have to fix that later.","title":"Technical debt 1"},{"location":"day-1/#setting-up-the-screen","text":"Zelia looks so small! That makes perfect sense because she's only about 30 pixels tall. The original game resolution was fullscreen and matched the aspect ratio of your active monitor to make the game 320px wide. After stumbling my own way through the settings, I looked up this guide on resolutions . Although I would have preferred the outcome to look like this: What I managed to achieve in godot by myself was blurry. However, this reddit thread came to the rescue to help me end up with this:","title":"Setting up the screen"},{"location":"day-1/#the-final-resizable-window-setup-im-happy-with","text":"Open Project > Project Settings Go to Display > Window Set Viewport Width to 320 And Viewport Height to 180 Make sure Mode is set to Windowed And that Resizable is checked to On Set the Stretch mode to canvas_items And the Aspect to keep Then open Render > Textures > Canvas Textures And change Filter to Nearest","title":"The final resizable window setup I'm happy with"},{"location":"day-1/#add-a-hitbox","text":"So the original Zelia had pixel perfect collisions. I wrote everything myself, so it was quite a battery hog in modern machines and a performance killer in older machines. However, I mainly did that to avoid having to draw hitboxes and doing polygon based collision math myself. If we want pixel perfect collision again, we'd probably follow this recipe on stackoverflow . For now, let's make do with a nice pill shape just like in the guide . Create another child node for Player of the type CollisionShape2D . Choose CapsuleShape2D in the inspector tab next to Shape 'Ungroup' the children of Player to make the CollisionShape2D selectable Align the box like in the screenshot below And 'group' them again. Save everything and test the current scene with F6 (make sure Zelia's in the viewport).","title":"Add a hitbox"},{"location":"day-1/#adding-controls","text":"The original game was written for a gamepad and tested with this (tr|d)usty controller: Keyboard and mouse were added later and work quite differently. So let's first create some dedicated inputs for running and jumping and see if we can fix the casting+aiming mechanic later.","title":"Adding controls"},{"location":"day-1/#input-map","text":"Open Project > Project Settings > Input Map . Add these new Actions : Run right Run left Jump Assign these keys to Run right : Keyboard 'D' - D (Physical) Keyboard Right arrow - Right (Physical) Joypad Axis 0 ( Left Stick Right , Joystick 0 Right - All Devices ) Joypad Button 14 ( D-pad Right - All Devices ) Assign these keys to Run left : Keyboard 'A' - A (Physical) Keyboard Left arrow - Left (Physical) Joypad Axis 0 ( Left Stick Left , Joystick 0 Left - All Devices ) Joypad Button 13 ( D-pad Left - All Devices ) And assign these keys to Jump : Keyboard 'W' - W (Physical) Keyboard Up arrow - Up (Physical) Joypad Button 0 - ( Buttom Action , Sony Cross , Xbox A , Ninendo B )","title":"Input Map"},{"location":"day-1/#player-script","text":"Finally, let's code some stuff, taking guidance from the official guide . Attach a script to the Player -node and save it in res://player/player.gd So in the original game there were some movement states I would like to keep using to make our rewrite easier: from enum import Enum class Orientation ( Enum ): LEFT = 1 RIGHT = 2 NONE = 3 UP = 4 DOWN = 5 class MovementState ( Enum ): IDLE = 1 RUNNING = 2 AIRBORNE = 3 JUMPING = 4 DYING = 5 CASTING = 6 FACING_FORWARD = 7 HOLDING_ITEM = 8 class CastDirection ( Enum ): DIAG_DOWN = 1 FORWARD = 2 DIAG_UP = 3 UP = 4 DOWN = 5 Let's read up on how to port these python style enums to gdscript. That looks nice and clean, let's define some inside our player.gd script for now. Let's assign them to some properties in the _ready() func. extends Area2D enum Orientation { LEFT , RIGHT } enum MovementState { IDLE , RUNNING , AIRBORNE } # We will want to debug these states, let's export them as well @ export var movement_state : int @ export var orientation : int func _ready (): movement_state = MovementState . IDLE orientation = Orientation . RIGHT func _process ( delta ): pass","title":"Player script"},{"location":"day-1/#test-run","text":"Run the current scene to test our property assignments. To debug exported properties while running, go to the node tree window and pick Remote in stead of Local : Then click the root -node first and then the Player -node. The Inspector tab for Player should now show: You can even change the property values through this interface!","title":"Test run"},{"location":"day-1/#implement-running-animations","text":"So let's now write some body for the _process() func. Let's first write tests for the Run right and Run left actions to set the movement func _process ( delta ): if Input . is_action_pressed ( \"Run right\" ): orientation = Orientation . RIGHT movement_state = MovementState . RUNNING elif Input . is_action_pressed ( \"Run left\" ): orientation = Orientation . LEFT movement_state = MovementState . RUNNING else : movement_state = MovementState . IDLE To test out whether our state changes work we run the current scene and open the Remote inspector for player. (Remember: click the root -node first and then the Player -node). I noticed a slight delay in the inspector, but I'm guessing that's due to it being on a lower priority thread.","title":"Implement running animations"},{"location":"day-1/#picking-the-right-animations-based-on-states","text":"Let's reread the guide on changing the animations. Add the following code at the bottom of the _process func: match ( movement_state ): MovementState . RUNNING : $ AnimatedSprite2D . animation = \"running\" _ : # MovementState.IDLE $ AnimatedSprite2D . animation = \"idle\" if orientation == Orientation . LEFT : $ AnimatedSprite2D . flip_h = true else : $ AnimatedSprite2D . flip_h = false And make sure our AnimatedSprite2D node starts playing in func _ready . func _ready (): movement_state = MovementState . IDLE orientation = Orientation . RIGHT $ AnimatedSprite2D . play () Test the current scene and if all is well our little Zelia is up and running! (pun intended)","title":"Picking the right animations based on states"},{"location":"day-1/#implementing-the-jump","text":"Ok so now we want her to jump! This is harder than it seems. It's not just a matter of if jump-is-pressed then draw jump : we are missing some environmental factors. Let's first define what we know about how jumping works. Test if the jump button was just pressed Input.is_action_just_pressed(\"Jump\") Player receives some negative y-acceleration Player spends some time in the air (i.e. is not touching a floor) Gravity (some positive y-acceleration) pulls the player back down. Seems like it would be a smart move to change the Player -node into a RigidBody2D at some stage. However, for now we just want to have some direct feedback from our inputs so let's mock some air time:","title":"Implementing the jump"},{"location":"day-1/#mock-airtime-node","text":"Create a new Timer node as a child node for Player and call it MockAirTimer ... or if you're deadset on it MockAirborneTimeTimer . :-) Let the Wait Time property remain at 1s and mark it as One Shot .","title":"Mock airtime node"},{"location":"day-1/#starting-the-mockairtimer-when-the-jump-button-was-pressed","text":"Change the _process func to match this snippet; changes and additions are under the comments. func _process ( delta ): # If user wants to jump, start the MockAirTimer and change the movement state to airborne if Input . is_action_just_pressed ( \"Jump\" ) and movement_state != MovementState . AIRBORNE : $ MockAirTimer . start () movement_state = MovementState . AIRBORNE if Input . is_action_pressed ( \"Run right\" ): orientation = Orientation . RIGHT # Only change movement state to running if not airborne movement_state = MovementState . RUNNING if movement_state != MovementState . AIRBORNE else MovementState . AIRBORNE elif Input . is_action_pressed ( \"Run left\" ): orientation = Orientation . LEFT # Only change movement state to running if not airborne movement_state = MovementState . RUNNING if movement_state != MovementState . AIRBORNE else MovementState . AIRBORNE else : # Only change movement state to idle if not airborne movement_state = MovementState . IDLE if movement_state != MovementState . AIRBORNE else MovementState . AIRBORNE match ( movement_state ): MovementState . RUNNING : $ AnimatedSprite2D . animation = \"running\" # This was added MovementState . AIRBORNE : $ AnimatedSprite2D . animation = \"jumping\" _ : # MovementState.IDLE $ AnimatedSprite2D . animation = \"idle\" if orientation == Orientation . LEFT : $ AnimatedSprite2D . flip_h = true else : $ AnimatedSprite2D . flip_h = false","title":"Starting the MockAirTimer when the jump button was pressed"},{"location":"day-1/#listening-to-the-mockairtimer-timeout","text":"If we let her jump now she will remain airborne forever. Let's not forget to add a listener to the MockAirTimer . Select the MockAirTimer -node in the node tree view and open the Node tab next to the Inspector tab. Double-click timeout() to open the Connect a Signal dialog: Leave all the defaults in place and click Connect","title":"Listening to the MockAirTimer timeout"},{"location":"day-1/#handle-the-timeout","text":"We now end up with the listener func _on_mock_air_timer_timeout to implement like this: func _on_mock_air_timer_timeout (): movement_state = MovementState . IDLE Run the player scene to test out the jump.","title":"Handle the timeout"},{"location":"day-1/#tweaking-the-timings","text":"Personally I think one second of air time is a little to long, so let's change it to 0.7s - not too long as to seem unnatural, yet long enough for her to change direction in the air.","title":"Tweaking the timings"},{"location":"day-1/#jump-sound","text":"Before we round up let's also add in the jump sound. Create a new child node for Player of type AudioStreamPlayer and call it JumpSound . Open up the Inspector and next to Stream use Quick load and pick jump-sound.wav from our resources dir. Then add this new line of code in _process : if Input . is_action_just_pressed ( \"Jump\" ) and movement_state != MovementState . AIRBORNE : $ JumpSound . play () # the new line","title":"Jump sound"},{"location":"day-1/#technical-debt-2","text":"The code is starting to look a little messy already, so we might want refactor at this point. No worries, we'll revisit this code often.","title":"Technical debt 2"},{"location":"day-1/#wrap-up","text":"Well that wraps up our day. I hope you enjoyed it as much as I did! Our next day will introduce some tiles and some movement: Day 2 - Adding some tiles and some physics Maybe we can even try out that RigidBody2D at some stage!","title":"Wrap up"},{"location":"day-2/","text":"Day 2 - Adding some tiles and some physics So today we're going to achieve these goals: Zelia will become subject to the laws of physics She will move right and left by running She will jump A camera will follow her around But before we can do that, we need some surfaces for her to run around on. Learning goals Before I could make this day's tutorial I had to read up on and watch: Using TileMaps Terrain Autotiling and Alternative Tiles ~ Godot 4 Tutorial for Beginners RigidBody2D CharacterBody2D platformer movement If you lost your project or want to start from here, I tagged the project after day one so you could clone or download it from github Addings Tiles in a TileMap First make sure you have some surface assets ready. Create a new resource dir called surface_maps and put the contents of this zip in it, including subdirs: Create the Tilemap Go Scene > New Scene and create new scene of type TileMap . Then rename it to World by double clicking on its node. Let's follow the steps in Using TileMaps and the video . From the Inpector do: Set the Cell Quadrant property to 15 Create a new TileSet Set the x and y of the Tile Size property to 15px Create a Physics Layer Create a Terrain Set Set the Mode property to Match Sides Add a Terrain and give it a bright green color Set the Name property to Grass and Dirt It should look like this now: Making an Atlas of an image Next open the Tileset pane on the bottom and add an Atlas using the + -button. Set the Texture property for this Atlas by loading the resource res://surface_maps/grass-and-dirt/1.png . Pick Yes when offered to automatically detect tiles: Set the Name property to grass-and-dirt Add the Terrain and Physics Layer to the tiles Now choose the select tab select all the tiles. Pop open > Terrains . Set Terrain Set to 0 (the number found by hovering over the Inspector > World > Terrain Sets property) Set Terrain to 0 (the number found by hovering over the Inspector > World > Terrain Sets > Terrains property) Pop open Physics > Physics Layer 0 (we just created that) Give the tiles their collision area To Set up the collision area of a tile you can select one at a time and press the F -key. This will make a square you can change into another type of polygon (we'll do that later): Apply this to all 15 tiles. Set the Terrains Peering Bit for each tile You can paint this! (it's in the video ). Go to the Paint tab. Select a property editor: Terrains Pick Terrain Set 0 for Terrain Set Pick Grass and Dirt for Terrain Now paint over the tiles so they look like this: We need one Alternative Tile There is one type of tile missing, the one that has neighbors on all four sides. We can achieve this by making an Alternative Tile . Go to Select Select the tile that is all dirt (x = 15 and y = 15) Right click on it Choose Create an Alternative Tile Press F to give it a collision rect Go back to Paint Click on the new tile Paint it to neighbour all sides: Paint some terrain If we did all this correctly, now we should be able to paint some Tiles on the viewport. Choose TileMap on the bottom of the Tiles tab Choose the Terrains tab Pick Terrain Set 0 > Grass and Dirt Choose the Rectangles draw mode Drag a rectangular area in the World -scene viewport. All this work should allow you to draw these shapes into the viewport in no time: Don't forget to save! I almost forgot myself. Press Ctrl-S to save the World -scene into rest://world.tscn Technical debt 3 After reading up about TileMap - including developers' opinions about it, I concluded that at this point I can safe create one TileMap -scene, call it World , and assume we will be making all the level content in it. This violates some of the SOLID principles, i.e. it does not separate the concern of tiles from the concern of a map/level/world, but we will accept this potential technical debt. Import some more Atlases If you carefully follow the same recipe you can of course create more Terrains for Terrain Set 0 this way. Just one screenshot hint for the one I added res://surface_maps/tree-trunk/1.png . It's about adjusting the collision area by manipulating the initial rectangle after pressing F : Add the Player to the World scene Let's add the Player -node as an instance into this World -scene. Just drag her scene file from the FileSystem tab into the tree view : res://player/player.tscn , like in the first tutorials. Test the current scene. Actually make the World -scene the main scene by right clicking on world.tscn in the FileSystem tab and picking Set as Main Scene . Use F5 or your OS's shortcut to run the entire project. There is a lot missing, we can't leave Zelia just hanging there! (ha ha ha). Make her subject to the laws of physics. Like we speculated during day 1, we need to change her Node Type if we do not want to write all the physics ourselves. And I don't. I did it last time and it took me weeks and weeks of tweaking; and there are sure to still be bugs hanging around. First attempt with RigidBody2D In my first attempt I actually tried to make Player extend from RigidBody2D and failed to get a good enough grip on what was happening. Second attempt with CharacterBody2D For my second attempt I read up on CharacterBody2D platformer movement . Let's try that out now. Go to the Player scene view (the one where she is the root node). Right click on Player Pick Change type Choose CharacterBody2D Edit res://player/player.gd and change the extends line: extends CharacterBody2D # this first line changed! Test by running the project. That changed nothing (for now). Adapting her script to CharacterBody2D So let's try this out: CharacterBody2D platformer movement . Much has change, feel free to copy/paste this first and see if it works, but you probably know the most imporant law of cheating with Stackoverflow : type it out yourself to learn better. extends CharacterBody2D enum Orientation { LEFT , RIGHT } enum MovementState { IDLE , RUNNING , AIRBORNE } # I removed the exports for now, no debugging needed at the moment var movement_state : int var orientation : int # Get the gravity from the project settings so you can sync with rigid body nodes. # NOTE: I changed the default from 980 to 1300, Zelia jumps high yet falls fast. var gravity = ProjectSettings . get_setting ( \"physics/2d/default_gravity\" ) # The most realistic speed for Zelia's feet var speed = 120.0 # Funnily the original game had jump_speed set to -4.0 and gravity to 13.0 var jump_speed = - 400.0 # No changes here func _ready (): movement_state = MovementState . IDLE orientation = Orientation . RIGHT $ AnimatedSprite2D . play () # Changed _process to _physics_process func _physics_process ( delta ): # Apply the gravity. velocity . y += gravity * delta # Update the MovementState based on the collisions observed if movement_state == MovementState . AIRBORNE : # If she's airborne right now if is_on_floor (): # .. and hits the floor, she's idle movement_state = MovementState . IDLE elif Input . is_action_pressed ( \"Run right\" ): # Else you can still move her right orientation = Orientation . RIGHT velocity . x = speed elif Input . is_action_pressed ( \"Run left\" ): # ... and left orientation = Orientation . LEFT velocity . x = - speed else : velocity . x = 0 else : # Else we are not airborne right now if Input . is_action_pressed ( \"Run right\" ): # so we run right when run right is pressed orientation = Orientation . RIGHT movement_state = MovementState . RUNNING velocity . x = speed elif Input . is_action_pressed ( \"Run left\" ): # .. and left ... orientation = Orientation . LEFT movement_state = MovementState . RUNNING velocity . x = - speed else : # and stand idle if no x-movement button is pressed velocity . x = 0 movement_state = MovementState . IDLE # Handle Jump, only when on the floor if Input . is_action_just_pressed ( \"Jump\" ) and is_on_floor (): $ JumpSound . play () movement_state = MovementState . AIRBORNE velocity . y = jump_speed # This code has not changed match ( movement_state ): MovementState . RUNNING : $ AnimatedSprite2D . animation = \"running\" # This was added MovementState . AIRBORNE : $ AnimatedSprite2D . animation = \"jumping\" _ : # MovementState.IDLE $ AnimatedSprite2D . animation = \"idle\" # Neither has this if orientation == Orientation . LEFT : $ AnimatedSprite2D . flip_h = true else : $ AnimatedSprite2D . flip_h = false # Yet this is new move_and_slide () And it just works! Frankly: it's much better than the original. If you are as new to Godot and perfab 2D physics engines as I am, make sure you read the tutorial and the docs carefully and try to write the script yourself: CharacterBody2D platformer movement CharacterBody2D class reference Change the gravity setting As I my mentioned in the code comments, I changed the Project's default gravity setting from 980 to 1300 : Go to Project > Project Settings Click on Filter Settings Type in gravity Pick Physics > 2D Set Default Gravity to 1300 Make it scroll with Camera2D The original Zelia never ever left the center of the screen; everything else just moved. I read somewhere that it would be easy: just add a Camera2D child node to the Player -node. This evening my son asked me for a demo, so I proposed to him we check it out.. He was amazed: \"De dingen waarvan je verwacht dat ze kort duren om te maken duren gewoon kort om te maken!\" (That is Dutch for: \"The things you'd expect a short time to make actually take a short time to make!\"). Right click the Player -node Click Add Child Node Pick Camera2D Start the game Voil\u00e1. Dead code Code cleanup We left some dead code. Let's fix that before wrapping up our day. In our new script we to away the need for our MockAirTimer . So let's remove it. Removing the _on_mock_air_timer_timeout signal Just to be sure, let's disconnect the signal we made first: Select the MockerAirTimer node in the treeview of the Player scene Click the Node tab next to Inspector Right click .. ::_on_mock_air_timer_timeout() Choose Disconnect Remove MockAirTimer itself Right click on the MockAirTimer -node in the tree view and delete it. Make sure all references to it in player.gd are gone as well, or you'll get a reference error. Technical debt 4 We have some poorly chosen names. I am we can do better than \"Run Right\" and \"Run Left\" knowing that they are already doubling for changing direction while airborne. But let's set some goals for tomorrow: Day 3 - Casting Fireballs","title":"Day 2 - Adding some tiles and some physics"},{"location":"day-2/#day-2-adding-some-tiles-and-some-physics","text":"So today we're going to achieve these goals: Zelia will become subject to the laws of physics She will move right and left by running She will jump A camera will follow her around But before we can do that, we need some surfaces for her to run around on.","title":"Day 2 - Adding some tiles and some physics"},{"location":"day-2/#learning-goals","text":"Before I could make this day's tutorial I had to read up on and watch: Using TileMaps Terrain Autotiling and Alternative Tiles ~ Godot 4 Tutorial for Beginners RigidBody2D CharacterBody2D platformer movement If you lost your project or want to start from here, I tagged the project after day one so you could clone or download it from github","title":"Learning goals"},{"location":"day-2/#addings-tiles-in-a-tilemap","text":"First make sure you have some surface assets ready. Create a new resource dir called surface_maps and put the contents of this zip in it, including subdirs:","title":"Addings Tiles in a TileMap"},{"location":"day-2/#create-the-tilemap","text":"Go Scene > New Scene and create new scene of type TileMap . Then rename it to World by double clicking on its node. Let's follow the steps in Using TileMaps and the video . From the Inpector do: Set the Cell Quadrant property to 15 Create a new TileSet Set the x and y of the Tile Size property to 15px Create a Physics Layer Create a Terrain Set Set the Mode property to Match Sides Add a Terrain and give it a bright green color Set the Name property to Grass and Dirt It should look like this now:","title":"Create the Tilemap"},{"location":"day-2/#making-an-atlas-of-an-image","text":"Next open the Tileset pane on the bottom and add an Atlas using the + -button. Set the Texture property for this Atlas by loading the resource res://surface_maps/grass-and-dirt/1.png . Pick Yes when offered to automatically detect tiles: Set the Name property to grass-and-dirt","title":"Making an Atlas of an image"},{"location":"day-2/#add-the-terrain-and-physics-layer-to-the-tiles","text":"Now choose the select tab select all the tiles. Pop open > Terrains . Set Terrain Set to 0 (the number found by hovering over the Inspector > World > Terrain Sets property) Set Terrain to 0 (the number found by hovering over the Inspector > World > Terrain Sets > Terrains property) Pop open Physics > Physics Layer 0 (we just created that)","title":"Add the Terrain and Physics Layer to the tiles"},{"location":"day-2/#give-the-tiles-their-collision-area","text":"To Set up the collision area of a tile you can select one at a time and press the F -key. This will make a square you can change into another type of polygon (we'll do that later): Apply this to all 15 tiles.","title":"Give the tiles their collision area"},{"location":"day-2/#set-the-terrains-peering-bit-for-each-tile","text":"You can paint this! (it's in the video ). Go to the Paint tab. Select a property editor: Terrains Pick Terrain Set 0 for Terrain Set Pick Grass and Dirt for Terrain Now paint over the tiles so they look like this:","title":"Set the Terrains Peering Bit for each tile"},{"location":"day-2/#we-need-one-alternative-tile","text":"There is one type of tile missing, the one that has neighbors on all four sides. We can achieve this by making an Alternative Tile . Go to Select Select the tile that is all dirt (x = 15 and y = 15) Right click on it Choose Create an Alternative Tile Press F to give it a collision rect Go back to Paint Click on the new tile Paint it to neighbour all sides:","title":"We need one Alternative Tile"},{"location":"day-2/#paint-some-terrain","text":"If we did all this correctly, now we should be able to paint some Tiles on the viewport. Choose TileMap on the bottom of the Tiles tab Choose the Terrains tab Pick Terrain Set 0 > Grass and Dirt Choose the Rectangles draw mode Drag a rectangular area in the World -scene viewport. All this work should allow you to draw these shapes into the viewport in no time:","title":"Paint some terrain"},{"location":"day-2/#dont-forget-to-save","text":"I almost forgot myself. Press Ctrl-S to save the World -scene into rest://world.tscn","title":"Don't forget to save!"},{"location":"day-2/#technical-debt-3","text":"After reading up about TileMap - including developers' opinions about it, I concluded that at this point I can safe create one TileMap -scene, call it World , and assume we will be making all the level content in it. This violates some of the SOLID principles, i.e. it does not separate the concern of tiles from the concern of a map/level/world, but we will accept this potential technical debt.","title":"Technical debt 3"},{"location":"day-2/#import-some-more-atlases","text":"If you carefully follow the same recipe you can of course create more Terrains for Terrain Set 0 this way. Just one screenshot hint for the one I added res://surface_maps/tree-trunk/1.png . It's about adjusting the collision area by manipulating the initial rectangle after pressing F :","title":"Import some more Atlases"},{"location":"day-2/#add-the-player-to-the-world-scene","text":"Let's add the Player -node as an instance into this World -scene. Just drag her scene file from the FileSystem tab into the tree view : res://player/player.tscn , like in the first tutorials. Test the current scene. Actually make the World -scene the main scene by right clicking on world.tscn in the FileSystem tab and picking Set as Main Scene . Use F5 or your OS's shortcut to run the entire project. There is a lot missing, we can't leave Zelia just hanging there! (ha ha ha).","title":"Add the Player to the World scene"},{"location":"day-2/#make-her-subject-to-the-laws-of-physics","text":"Like we speculated during day 1, we need to change her Node Type if we do not want to write all the physics ourselves. And I don't. I did it last time and it took me weeks and weeks of tweaking; and there are sure to still be bugs hanging around.","title":"Make her subject to the laws of physics."},{"location":"day-2/#first-attempt-with-rigidbody2d","text":"In my first attempt I actually tried to make Player extend from RigidBody2D and failed to get a good enough grip on what was happening.","title":"First attempt with RigidBody2D"},{"location":"day-2/#second-attempt-with-characterbody2d","text":"For my second attempt I read up on CharacterBody2D platformer movement . Let's try that out now. Go to the Player scene view (the one where she is the root node). Right click on Player Pick Change type Choose CharacterBody2D Edit res://player/player.gd and change the extends line: extends CharacterBody2D # this first line changed! Test by running the project. That changed nothing (for now).","title":"Second attempt with CharacterBody2D"},{"location":"day-2/#adapting-her-script-to-characterbody2d","text":"So let's try this out: CharacterBody2D platformer movement . Much has change, feel free to copy/paste this first and see if it works, but you probably know the most imporant law of cheating with Stackoverflow : type it out yourself to learn better. extends CharacterBody2D enum Orientation { LEFT , RIGHT } enum MovementState { IDLE , RUNNING , AIRBORNE } # I removed the exports for now, no debugging needed at the moment var movement_state : int var orientation : int # Get the gravity from the project settings so you can sync with rigid body nodes. # NOTE: I changed the default from 980 to 1300, Zelia jumps high yet falls fast. var gravity = ProjectSettings . get_setting ( \"physics/2d/default_gravity\" ) # The most realistic speed for Zelia's feet var speed = 120.0 # Funnily the original game had jump_speed set to -4.0 and gravity to 13.0 var jump_speed = - 400.0 # No changes here func _ready (): movement_state = MovementState . IDLE orientation = Orientation . RIGHT $ AnimatedSprite2D . play () # Changed _process to _physics_process func _physics_process ( delta ): # Apply the gravity. velocity . y += gravity * delta # Update the MovementState based on the collisions observed if movement_state == MovementState . AIRBORNE : # If she's airborne right now if is_on_floor (): # .. and hits the floor, she's idle movement_state = MovementState . IDLE elif Input . is_action_pressed ( \"Run right\" ): # Else you can still move her right orientation = Orientation . RIGHT velocity . x = speed elif Input . is_action_pressed ( \"Run left\" ): # ... and left orientation = Orientation . LEFT velocity . x = - speed else : velocity . x = 0 else : # Else we are not airborne right now if Input . is_action_pressed ( \"Run right\" ): # so we run right when run right is pressed orientation = Orientation . RIGHT movement_state = MovementState . RUNNING velocity . x = speed elif Input . is_action_pressed ( \"Run left\" ): # .. and left ... orientation = Orientation . LEFT movement_state = MovementState . RUNNING velocity . x = - speed else : # and stand idle if no x-movement button is pressed velocity . x = 0 movement_state = MovementState . IDLE # Handle Jump, only when on the floor if Input . is_action_just_pressed ( \"Jump\" ) and is_on_floor (): $ JumpSound . play () movement_state = MovementState . AIRBORNE velocity . y = jump_speed # This code has not changed match ( movement_state ): MovementState . RUNNING : $ AnimatedSprite2D . animation = \"running\" # This was added MovementState . AIRBORNE : $ AnimatedSprite2D . animation = \"jumping\" _ : # MovementState.IDLE $ AnimatedSprite2D . animation = \"idle\" # Neither has this if orientation == Orientation . LEFT : $ AnimatedSprite2D . flip_h = true else : $ AnimatedSprite2D . flip_h = false # Yet this is new move_and_slide () And it just works! Frankly: it's much better than the original. If you are as new to Godot and perfab 2D physics engines as I am, make sure you read the tutorial and the docs carefully and try to write the script yourself: CharacterBody2D platformer movement CharacterBody2D class reference","title":"Adapting her script to CharacterBody2D"},{"location":"day-2/#change-the-gravity-setting","text":"As I my mentioned in the code comments, I changed the Project's default gravity setting from 980 to 1300 : Go to Project > Project Settings Click on Filter Settings Type in gravity Pick Physics > 2D Set Default Gravity to 1300","title":"Change the gravity setting"},{"location":"day-2/#make-it-scroll-with-camera2d","text":"The original Zelia never ever left the center of the screen; everything else just moved. I read somewhere that it would be easy: just add a Camera2D child node to the Player -node. This evening my son asked me for a demo, so I proposed to him we check it out.. He was amazed: \"De dingen waarvan je verwacht dat ze kort duren om te maken duren gewoon kort om te maken!\" (That is Dutch for: \"The things you'd expect a short time to make actually take a short time to make!\"). Right click the Player -node Click Add Child Node Pick Camera2D Start the game Voil\u00e1.","title":"Make it scroll with Camera2D"},{"location":"day-2/#dead-code-code-cleanup","text":"We left some dead code. Let's fix that before wrapping up our day. In our new script we to away the need for our MockAirTimer . So let's remove it.","title":"Dead code Code cleanup"},{"location":"day-2/#removing-the-_on_mock_air_timer_timeout-signal","text":"Just to be sure, let's disconnect the signal we made first: Select the MockerAirTimer node in the treeview of the Player scene Click the Node tab next to Inspector Right click .. ::_on_mock_air_timer_timeout() Choose Disconnect","title":"Removing the _on_mock_air_timer_timeout signal"},{"location":"day-2/#remove-mockairtimer-itself","text":"Right click on the MockAirTimer -node in the tree view and delete it. Make sure all references to it in player.gd are gone as well, or you'll get a reference error.","title":"Remove MockAirTimer itself"},{"location":"day-2/#technical-debt-4","text":"We have some poorly chosen names. I am we can do better than \"Run Right\" and \"Run Left\" knowing that they are already doubling for changing direction while airborne. But let's set some goals for tomorrow: Day 3 - Casting Fireballs","title":"Technical debt 4"},{"location":"day-3/","text":"Day 3 - Casting Sprites Today we're going to add Zelia's casting sprites to her script. Want to start from here? Clone or download the result of day 2 from github Learning goals Determine the angle between the Zelia sprite and the mouse cursor Determine the angle of the L-stick Using rad_to_deg to determing the correct casting sprite for aiming Code refactor to tidy up code and make it more maintainable The steps for today Assign casting buttons Fix the casting sprites for Zelia (Technical debt 1) Determine cast direction via mouse cursor position and L-stick axis Rearrange the code in _physics_process a little Draw the correct casting sprites based on cast direction Extract some functions for less messy code (Technical debt 2) Assign casting buttons After day 3 Zelia will cast fireballs in all directions: - when holding gamepad button B , you can aim with the L-stick - when holding the left mouse button, you can aim with the mouse cursor. Go to Project > Project Settings Go to Input Maps Choose Add New Action Set the name to Fireball button Assign Left Mouse Button to Fireball button Assign Joypad Button 1 to Fireball button Now to determine which of either is pressed we need to assign one to another name. Choose Add New Action Set the name to Left mouse button Assign Left Mouse Button to your new action named Left mouse button Fix the casting sprites for Zelia On day 1 we added one SpriteFrames entry for all casting images. We should have made an entry per image to cover all her angles of casting: Go to FileSystem > res:// > player > player.tscn Go to Scene > Player > AnimatedSprite2D On the bottom pane choose casting Rename it to casting_down (click on it a second time) Select the image casting forward Press Ctrl-C to copy it Add a new Animation named casting_forward Click on the preview window Select it and press Ctrl-V to paste the image of Zelia casting forward Repeat this process until you have 4 entries: casting_up , casting_diag_up , casting_forward and casting_down Remove the images not casting down from the casting_down animation: Note : the image called casting_down will also be used for casting down diagonally. (Her arms look really silly when pointing directly down) Determine cast direction via mouse cursor position and L-stick axis First let's write some code to see if we can set the angle of casting when one of the Fireball button s is pressed. Later on we'll pick the correct sprite, based on her angle of casting Go to FileSystem > player > player.gd to edit the script. Add a movement state for casting: enum MovementState { IDLE , RUNNING , AIRBORNE , CASTING } Add a property for the direction of casting @ export var cast_angle : float In the _physics_process set cast_angle and movement_state right above the jump code if Input . is_action_pressed ( \"Fireball button\" ): movement_state = MovementState . CASTING # base the angle of casting on the position of the mouse # relative to Zelia or on the L-stick if Input . is_action_pressed ( \"Left mouse button\" ): cast_angle = ( get_global_mouse_position () - position ) . normalized () . angle () else : cast_angle = Vector2 ( Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_X ), Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_Y )) . normalized () . angle () # Handle Jump, only when on the floor Test via remote debugging This time we will monitor the exported property cast_angle . If you forgot how, I documented it on day 1. Remote debug see Run the main scene with F5 to see if the Cast Angle property changes when either: Pick Remote Go to root > World > Player Look at the inspector Check and see if the Cast Angle value changes when you: - left-click the mouse somewhere in the game window - press B and move the L-stick (the player wil slide around in looking idle right now) Rearrange the code in _physics_process a little NOTE This section will rearrange code to look like this, in case you get stuck: player.gd You could also download it and skip to the next section . Let's get started We need to rearrange our code in the _physics_process a little in order to achieve 2 things: Let Zelia flip orientation based on her casting angle Let Zelia stop jumping and moving on the x-axis while casting Flipping the player left and right by aiming Extend the code in the if -block we just created for setting the cast_angle to include setting the orientation -property correctly. if Input . is_action_pressed ( \"Fireball button\" ): ## ... movement_state and cast_angle are still set here # base her orientation on the angle of casting as well if cast_angle > - ( PI * 0.5 ) and cast_angle < PI * 0.5 : orientation = Orientation . RIGHT else : orientation = Orientation . LEFT Test using F5 : when clicking with the mouse left of her she should now flip to look left. Letting Zelia stop jumping and moving on the x-axis while casting When she's casting she should not slide sideways. We don't want her to be able to move horizontally while casting in the air (which would make her way too powerful). Step 1, move casting code up, stop her from sliding First move your entire if Input.is_action_pressed(\"Fireball button\") -block all the way up to below velocity.y += gravity * delta . Change if movement_state == MovementState.AIRBORNE into elif movement_state == MovementState.AIRBORNE if Input . is_action_pressed ( \"Fireball button\" ): movement_state = MovementState . CASTING # base the angle of casting on the position of the mouse # relative to Zelia or on the L-stick if Input . is_action_pressed ( \"Left mouse button\" ): cast_angle = ( get_global_mouse_position () - position ) . normalized () . angle () else : cast_angle = Vector2 ( Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_X ), Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_Y )) . normalized () . angle () # base her orientation on the angle of casting as well if cast_angle > - ( PI * 0.5 ) and cast_angle < PI * 0.5 : orientation = Orientation . RIGHT else : orientation = Orientation . LEFT elif movement_state == MovementState . AIRBORNE : This stops her from sliding or moving around while in the air. Step 2, only jump when not casting and not airborne She can still jump while casting now, let's fix that. Indent the if Input.is_action_just_pressed(\"Jump\") and is_on_floor() to make it part of the else -case matching not casting and not being airborne else : # Else we are not airborne right now if Input . is_action_pressed ( \"Run right\" ): # so we run right when run right is pressed orientation = Orientation . RIGHT movement_state = MovementState . RUNNING velocity . x = speed elif Input . is_action_pressed ( \"Run left\" ): # .. and left ... orientation = Orientation . LEFT movement_state = MovementState . RUNNING velocity . x = - speed else : # and stand idle if no x-movement button is pressed velocity . x = 0 movement_state = MovementState . IDLE ## This is new # Handle Jump, only when on the floor if Input . is_action_just_pressed ( \"Jump\" ): $ JumpSound . play () movement_state = MovementState . AIRBORNE velocity . y = jump_speed That stopped her from jumping while casting Step 3, separate code for setting initial movement state from code updating positions. This step will have no functional effect, but it will prepare us for our \"readable code refactor\" that comes next. First create this new if-block just under velocity.y += gravity * delta : # Set initial movement state if Input . is_action_pressed ( \"Fireball button\" ): movement_state = MovementState . CASTING # base the angle of casting on the position of the mouse # relative to Zelia or on the L-stick if Input . is_action_pressed ( \"Left mouse button\" ): cast_angle = ( get_global_mouse_position () - position ) . normalized () . angle () else : cast_angle = Vector2 ( Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_X ), Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_Y )) . normalized () . angle () elif is_on_floor (): movement_state = MovementState . IDLE else : movement_state = MovementState . AIRBORNE Second Replace the old if Input.is_action_pressed(\"Fireball button\") -block with this code: # Update movement state, velocity and orientation based on the combo of # her current movement state and environmental factors if movement_state == MovementState . CASTING : # She cannot run or move on x-axis in the air while casting velocity . x = 0 # base her orientation on the angle of casting as well if cast_angle > - ( PI * 0.5 ) and cast_angle < PI * 0.5 : orientation = Orientation . RIGHT else : orientation = Orientation . LEFT elif movement_state == MovementState . AIRBORNE : Your script should now look like this: player.gd (tag = letting-zelia-stop-x-on-cast) Draw the correct casting sprites based on cast direction Let's make a well-named function to choose the correct sprite name to draw: func get_casting_sprite ## Determine the casting sprite name based on decimal degrees func get_casting_sprite ( deg ) -> String : var casting_left = ( deg > 120 and deg < 180 ) or ( deg > - 180 and deg < - 120 ) var casting_right = deg > - 60 and deg < 60 var casting_up = deg > - 140 and deg < - 20 var casting_down = deg > 30 and deg < 150 if casting_up and ( casting_right or casting_left ): return \"casting_diag_up\" elif casting_down and ( casting_right or casting_left ): return \"casting_down\" elif casting_up : return \"casting_up\" elif casting_down : return \"casting_down\" else : return \"casting_forward\" As you can see, this function expects the cast_angle to be passed as decimal degrees in stead of radians . This makes the code a little more self-documenting, at the cost of some minimal performance. Now let's also add the case for MovementState.CASTING to our match -statement: # Determine sprite based on movement state match ( movement_state ): MovementState . RUNNING : $ AnimatedSprite2D . animation = \"running\" # This was added MovementState . AIRBORNE : $ AnimatedSprite2D . animation = \"jumping\" MovementState . CASTING : # when casting invoke get_casting_sprite to set the correct # animation name $ AnimatedSprite2D . animation = get_casting_sprite ( rad_to_deg ( cast_angle )) _ : # MovementState.IDLE $ AnimatedSprite2D . animation = \"idle\" Note the rad_to_deg there. Extract some functions for less messy code Now it's really time to fix Technical debt 2 , because the debt became deeper. NOTE : if you're already familiar with code refactors or want/need a reference, you can download the final code of today here: - player.gd And if you're already quite familiar with these types of refactor, here's a skip link to day 4: - Day 4 - Casting fireballs The process of tyding up code Now there must be a pattern or best practice name for this, but here's how it goes. Spot a function with a lot of code in the function body and do: 1. For each bit of code needs comments to explain what it does, create a function named after the comments. 2. For each block of code handling a case in an if-block write a function that says what it handles 3. For each line of code longer than your coding viewport, write functions to shorten that line 4. For each complex boolean evaluation write a function with a name that says what it does 5. For each code repetition write a function to be reused ... etcetera. This refactor only applied step 1 , 2 and 3 Spot a big function and apply the steps! Let's rewrite the above code again. We spot that _physics_process is now almost 100 lines long! Step 1 - code that needs comments: # Handle casting if Input . is_action_pressed ( \"Fireball button\" ): movement_state = MovementState . CASTING # base the angle of casting on the position of the mouse # relative to Zelia or on the L-stick if Input . is_action_pressed ( \"Left mouse button\" ): cast_angle = ( get_global_mouse_position () - position ) . normalized () . angle () else : cast_angle = Vector2 ( Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_X ), Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_Y )) . normalized () . angle () elif is_on_floor (): movement_state = MovementState . IDLE else : movement_state = MovementState . AIRBORNE Is moved to a separate function named set_movement_state . # Set initial movement state func set_movement_state (): if Input . is_action_pressed ( \"Fireball button\" ): movement_state = MovementState . CASTING # base the angle of casting on the position of the mouse # relative to Zelia or on the L-stick if Input . is_action_pressed ( \"Left mouse button\" ): cast_angle = ( get_global_mouse_position () - position ) . normalized () . angle () else : cast_angle = Vector2 ( Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_X ), Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_Y )) . normalized () . angle () elif is_on_floor (): movement_state = MovementState . IDLE else : movement_state = MovementState . AIRBORNE Step 1 can be applied again to this new function: # base the angle of casting on the position of the mouse relative to Zelia func set_cast_angle (): if Input . is_action_pressed ( \"Left mouse button\" ): cast_angle = ( get_global_mouse_position () - position ) . normalized () . angle () else : cast_angle = Vector2 ( Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_X ), Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_Y )) . normalized () . angle () # Set initial movement state func set_movement_state (): if Input . is_action_pressed ( \"Fireball button\" ): movement_state = MovementState . CASTING set_cast_angle () elif is_on_floor (): movement_state = MovementState . IDLE else : movement_state = MovementState . AIRBORNE Now both step 2 and 3 still apply to this new function: # Vector of L-stick func get_l_stick_axis_vec () -> Vector2 : return Vector2 ( Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_X ), Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_Y ) ) # Vector from player to mouse position func get_mouse_vec_to_player () -> Vector2 : return get_global_mouse_position () - position # base the angle of casting on the position of the mouse relative to Zelia func set_cast_angle (): if Input . is_action_pressed ( \"Left mouse button\" ): cast_angle = get_mouse_vec_to_player () . normalized () . angle () else : cast_angle = get_l_stick_axis_vec () . normalized () . angle () Rinse and repeat! Now we spot this elaborate comment: \"Update movement state, velocity and orientation based on the combo of her current movement state and environmental factors\" Applying the refactor steps listed previously do: 1. Create a function handle_movement_state 2. Cut+paste all the code under the long comment up to above the match call into handle_movement_state 3. Call handle_movement_state() after set_movement_state() 4. Create a func handle_casting 5. Cut+paste all the code within the block if movement_state == MovementState.CASTING: into it 6. Call handle_casting() in this if block 7. Do the same for handle_airborne() under elif movement_state == MovementState.AIRBORNE: 8. And make 2 functions to be called under else: - handle_running() and handle_jumping() Your final func handle_movement_state() should now look like this. # Main movement state handler entry point func handle_movement_state (): if movement_state == MovementState . CASTING : handle_casting () elif movement_state == MovementState . AIRBORNE : handle_airborne () else : handle_running () handle_jumping () Just 2 more funcs! Create the function set_current_sprite Put the entire block of match (movement_state): in it Invoke it under handle_movement_state() And : Create the function flip_current_sprite Put the entire if-else block of if orientation == Orientation.LEFT: in it Invoke it under set_current_sprite() All tidied up Your _physics_process should now look like this: # Changed _process to _physics_process func _physics_process ( delta ): # Apply the gravity. velocity . y += gravity * delta # Set, and handle movement state set_movement_state () handle_movement_state () # Set the correct sprite based on movement state set_current_sprite () # Determine sprite-flip based on orientation flip_current_sprite () # Apply 2d physics engine's movement move_and_slide () And everything should still work. Your entire player.gd script should look like this: player.gd - on github commit: \"use my own tutorial for day-3 part 1.\" Technical debt 5 Two observation on remaining technical debt: Our comments probably do not conform to documentation guidelines Some coding conventions might not comply either Let's park that and go right on ahead to: Day 4 - Casting Fireballs","title":"Day 3 - Casting Sprites"},{"location":"day-3/#day-3-casting-sprites","text":"Today we're going to add Zelia's casting sprites to her script. Want to start from here? Clone or download the result of day 2 from github","title":"Day 3 - Casting Sprites"},{"location":"day-3/#learning-goals","text":"Determine the angle between the Zelia sprite and the mouse cursor Determine the angle of the L-stick Using rad_to_deg to determing the correct casting sprite for aiming Code refactor to tidy up code and make it more maintainable","title":"Learning goals"},{"location":"day-3/#the-steps-for-today","text":"Assign casting buttons Fix the casting sprites for Zelia (Technical debt 1) Determine cast direction via mouse cursor position and L-stick axis Rearrange the code in _physics_process a little Draw the correct casting sprites based on cast direction Extract some functions for less messy code (Technical debt 2)","title":"The steps for today"},{"location":"day-3/#assign-casting-buttons","text":"After day 3 Zelia will cast fireballs in all directions: - when holding gamepad button B , you can aim with the L-stick - when holding the left mouse button, you can aim with the mouse cursor. Go to Project > Project Settings Go to Input Maps Choose Add New Action Set the name to Fireball button Assign Left Mouse Button to Fireball button Assign Joypad Button 1 to Fireball button Now to determine which of either is pressed we need to assign one to another name. Choose Add New Action Set the name to Left mouse button Assign Left Mouse Button to your new action named Left mouse button","title":"Assign casting buttons"},{"location":"day-3/#fix-the-casting-sprites-for-zelia","text":"On day 1 we added one SpriteFrames entry for all casting images. We should have made an entry per image to cover all her angles of casting: Go to FileSystem > res:// > player > player.tscn Go to Scene > Player > AnimatedSprite2D On the bottom pane choose casting Rename it to casting_down (click on it a second time) Select the image casting forward Press Ctrl-C to copy it Add a new Animation named casting_forward Click on the preview window Select it and press Ctrl-V to paste the image of Zelia casting forward Repeat this process until you have 4 entries: casting_up , casting_diag_up , casting_forward and casting_down Remove the images not casting down from the casting_down animation: Note : the image called casting_down will also be used for casting down diagonally. (Her arms look really silly when pointing directly down)","title":"Fix the casting sprites for Zelia"},{"location":"day-3/#determine-cast-direction-via-mouse-cursor-position-and-l-stick-axis","text":"First let's write some code to see if we can set the angle of casting when one of the Fireball button s is pressed. Later on we'll pick the correct sprite, based on her angle of casting Go to FileSystem > player > player.gd to edit the script. Add a movement state for casting: enum MovementState { IDLE , RUNNING , AIRBORNE , CASTING } Add a property for the direction of casting @ export var cast_angle : float In the _physics_process set cast_angle and movement_state right above the jump code if Input . is_action_pressed ( \"Fireball button\" ): movement_state = MovementState . CASTING # base the angle of casting on the position of the mouse # relative to Zelia or on the L-stick if Input . is_action_pressed ( \"Left mouse button\" ): cast_angle = ( get_global_mouse_position () - position ) . normalized () . angle () else : cast_angle = Vector2 ( Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_X ), Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_Y )) . normalized () . angle () # Handle Jump, only when on the floor Test via remote debugging This time we will monitor the exported property cast_angle . If you forgot how, I documented it on day 1. Remote debug see Run the main scene with F5 to see if the Cast Angle property changes when either: Pick Remote Go to root > World > Player Look at the inspector Check and see if the Cast Angle value changes when you: - left-click the mouse somewhere in the game window - press B and move the L-stick (the player wil slide around in looking idle right now)","title":"Determine cast direction via mouse cursor position and L-stick axis"},{"location":"day-3/#rearrange-the-code-in-_physics_process-a-little","text":"NOTE This section will rearrange code to look like this, in case you get stuck: player.gd You could also download it and skip to the next section .","title":"Rearrange the code in _physics_process a little"},{"location":"day-3/#lets-get-started","text":"We need to rearrange our code in the _physics_process a little in order to achieve 2 things: Let Zelia flip orientation based on her casting angle Let Zelia stop jumping and moving on the x-axis while casting","title":"Let's get started"},{"location":"day-3/#flipping-the-player-left-and-right-by-aiming","text":"Extend the code in the if -block we just created for setting the cast_angle to include setting the orientation -property correctly. if Input . is_action_pressed ( \"Fireball button\" ): ## ... movement_state and cast_angle are still set here # base her orientation on the angle of casting as well if cast_angle > - ( PI * 0.5 ) and cast_angle < PI * 0.5 : orientation = Orientation . RIGHT else : orientation = Orientation . LEFT Test using F5 : when clicking with the mouse left of her she should now flip to look left.","title":"Flipping the player left and right by aiming"},{"location":"day-3/#letting-zelia-stop-jumping-and-moving-on-the-x-axis-while-casting","text":"When she's casting she should not slide sideways. We don't want her to be able to move horizontally while casting in the air (which would make her way too powerful).","title":"Letting Zelia stop jumping and moving on the x-axis while casting"},{"location":"day-3/#step-1-move-casting-code-up-stop-her-from-sliding","text":"First move your entire if Input.is_action_pressed(\"Fireball button\") -block all the way up to below velocity.y += gravity * delta . Change if movement_state == MovementState.AIRBORNE into elif movement_state == MovementState.AIRBORNE if Input . is_action_pressed ( \"Fireball button\" ): movement_state = MovementState . CASTING # base the angle of casting on the position of the mouse # relative to Zelia or on the L-stick if Input . is_action_pressed ( \"Left mouse button\" ): cast_angle = ( get_global_mouse_position () - position ) . normalized () . angle () else : cast_angle = Vector2 ( Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_X ), Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_Y )) . normalized () . angle () # base her orientation on the angle of casting as well if cast_angle > - ( PI * 0.5 ) and cast_angle < PI * 0.5 : orientation = Orientation . RIGHT else : orientation = Orientation . LEFT elif movement_state == MovementState . AIRBORNE : This stops her from sliding or moving around while in the air.","title":"Step 1, move casting code up, stop her from sliding"},{"location":"day-3/#step-2-only-jump-when-not-casting-and-not-airborne","text":"She can still jump while casting now, let's fix that. Indent the if Input.is_action_just_pressed(\"Jump\") and is_on_floor() to make it part of the else -case matching not casting and not being airborne else : # Else we are not airborne right now if Input . is_action_pressed ( \"Run right\" ): # so we run right when run right is pressed orientation = Orientation . RIGHT movement_state = MovementState . RUNNING velocity . x = speed elif Input . is_action_pressed ( \"Run left\" ): # .. and left ... orientation = Orientation . LEFT movement_state = MovementState . RUNNING velocity . x = - speed else : # and stand idle if no x-movement button is pressed velocity . x = 0 movement_state = MovementState . IDLE ## This is new # Handle Jump, only when on the floor if Input . is_action_just_pressed ( \"Jump\" ): $ JumpSound . play () movement_state = MovementState . AIRBORNE velocity . y = jump_speed That stopped her from jumping while casting","title":"Step 2, only jump when not casting and not airborne"},{"location":"day-3/#step-3-separate-code-for-setting-initial-movement-state-from-code-updating-positions","text":"This step will have no functional effect, but it will prepare us for our \"readable code refactor\" that comes next. First create this new if-block just under velocity.y += gravity * delta : # Set initial movement state if Input . is_action_pressed ( \"Fireball button\" ): movement_state = MovementState . CASTING # base the angle of casting on the position of the mouse # relative to Zelia or on the L-stick if Input . is_action_pressed ( \"Left mouse button\" ): cast_angle = ( get_global_mouse_position () - position ) . normalized () . angle () else : cast_angle = Vector2 ( Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_X ), Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_Y )) . normalized () . angle () elif is_on_floor (): movement_state = MovementState . IDLE else : movement_state = MovementState . AIRBORNE Second Replace the old if Input.is_action_pressed(\"Fireball button\") -block with this code: # Update movement state, velocity and orientation based on the combo of # her current movement state and environmental factors if movement_state == MovementState . CASTING : # She cannot run or move on x-axis in the air while casting velocity . x = 0 # base her orientation on the angle of casting as well if cast_angle > - ( PI * 0.5 ) and cast_angle < PI * 0.5 : orientation = Orientation . RIGHT else : orientation = Orientation . LEFT elif movement_state == MovementState . AIRBORNE : Your script should now look like this: player.gd (tag = letting-zelia-stop-x-on-cast)","title":"Step 3, separate code for setting initial movement state from code updating positions."},{"location":"day-3/#draw-the-correct-casting-sprites-based-on-cast-direction","text":"Let's make a well-named function to choose the correct sprite name to draw:","title":"Draw the correct casting sprites based on cast direction"},{"location":"day-3/#func-get_casting_sprite","text":"## Determine the casting sprite name based on decimal degrees func get_casting_sprite ( deg ) -> String : var casting_left = ( deg > 120 and deg < 180 ) or ( deg > - 180 and deg < - 120 ) var casting_right = deg > - 60 and deg < 60 var casting_up = deg > - 140 and deg < - 20 var casting_down = deg > 30 and deg < 150 if casting_up and ( casting_right or casting_left ): return \"casting_diag_up\" elif casting_down and ( casting_right or casting_left ): return \"casting_down\" elif casting_up : return \"casting_up\" elif casting_down : return \"casting_down\" else : return \"casting_forward\" As you can see, this function expects the cast_angle to be passed as decimal degrees in stead of radians . This makes the code a little more self-documenting, at the cost of some minimal performance. Now let's also add the case for MovementState.CASTING to our match -statement: # Determine sprite based on movement state match ( movement_state ): MovementState . RUNNING : $ AnimatedSprite2D . animation = \"running\" # This was added MovementState . AIRBORNE : $ AnimatedSprite2D . animation = \"jumping\" MovementState . CASTING : # when casting invoke get_casting_sprite to set the correct # animation name $ AnimatedSprite2D . animation = get_casting_sprite ( rad_to_deg ( cast_angle )) _ : # MovementState.IDLE $ AnimatedSprite2D . animation = \"idle\" Note the rad_to_deg there.","title":"func get_casting_sprite"},{"location":"day-3/#extract-some-functions-for-less-messy-code","text":"Now it's really time to fix Technical debt 2 , because the debt became deeper. NOTE : if you're already familiar with code refactors or want/need a reference, you can download the final code of today here: - player.gd And if you're already quite familiar with these types of refactor, here's a skip link to day 4: - Day 4 - Casting fireballs","title":"Extract some functions for less messy code"},{"location":"day-3/#the-process-of-tyding-up-code","text":"Now there must be a pattern or best practice name for this, but here's how it goes. Spot a function with a lot of code in the function body and do: 1. For each bit of code needs comments to explain what it does, create a function named after the comments. 2. For each block of code handling a case in an if-block write a function that says what it handles 3. For each line of code longer than your coding viewport, write functions to shorten that line 4. For each complex boolean evaluation write a function with a name that says what it does 5. For each code repetition write a function to be reused ... etcetera. This refactor only applied step 1 , 2 and 3","title":"The process of tyding up code"},{"location":"day-3/#spot-a-big-function-and-apply-the-steps","text":"Let's rewrite the above code again. We spot that _physics_process is now almost 100 lines long! Step 1 - code that needs comments: # Handle casting if Input . is_action_pressed ( \"Fireball button\" ): movement_state = MovementState . CASTING # base the angle of casting on the position of the mouse # relative to Zelia or on the L-stick if Input . is_action_pressed ( \"Left mouse button\" ): cast_angle = ( get_global_mouse_position () - position ) . normalized () . angle () else : cast_angle = Vector2 ( Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_X ), Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_Y )) . normalized () . angle () elif is_on_floor (): movement_state = MovementState . IDLE else : movement_state = MovementState . AIRBORNE Is moved to a separate function named set_movement_state . # Set initial movement state func set_movement_state (): if Input . is_action_pressed ( \"Fireball button\" ): movement_state = MovementState . CASTING # base the angle of casting on the position of the mouse # relative to Zelia or on the L-stick if Input . is_action_pressed ( \"Left mouse button\" ): cast_angle = ( get_global_mouse_position () - position ) . normalized () . angle () else : cast_angle = Vector2 ( Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_X ), Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_Y )) . normalized () . angle () elif is_on_floor (): movement_state = MovementState . IDLE else : movement_state = MovementState . AIRBORNE Step 1 can be applied again to this new function: # base the angle of casting on the position of the mouse relative to Zelia func set_cast_angle (): if Input . is_action_pressed ( \"Left mouse button\" ): cast_angle = ( get_global_mouse_position () - position ) . normalized () . angle () else : cast_angle = Vector2 ( Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_X ), Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_Y )) . normalized () . angle () # Set initial movement state func set_movement_state (): if Input . is_action_pressed ( \"Fireball button\" ): movement_state = MovementState . CASTING set_cast_angle () elif is_on_floor (): movement_state = MovementState . IDLE else : movement_state = MovementState . AIRBORNE Now both step 2 and 3 still apply to this new function: # Vector of L-stick func get_l_stick_axis_vec () -> Vector2 : return Vector2 ( Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_X ), Input . get_joy_axis ( 0 , JOY_AXIS_LEFT_Y ) ) # Vector from player to mouse position func get_mouse_vec_to_player () -> Vector2 : return get_global_mouse_position () - position # base the angle of casting on the position of the mouse relative to Zelia func set_cast_angle (): if Input . is_action_pressed ( \"Left mouse button\" ): cast_angle = get_mouse_vec_to_player () . normalized () . angle () else : cast_angle = get_l_stick_axis_vec () . normalized () . angle ()","title":"Spot a big function and apply the steps!"},{"location":"day-3/#rinse-and-repeat","text":"Now we spot this elaborate comment: \"Update movement state, velocity and orientation based on the combo of her current movement state and environmental factors\" Applying the refactor steps listed previously do: 1. Create a function handle_movement_state 2. Cut+paste all the code under the long comment up to above the match call into handle_movement_state 3. Call handle_movement_state() after set_movement_state() 4. Create a func handle_casting 5. Cut+paste all the code within the block if movement_state == MovementState.CASTING: into it 6. Call handle_casting() in this if block 7. Do the same for handle_airborne() under elif movement_state == MovementState.AIRBORNE: 8. And make 2 functions to be called under else: - handle_running() and handle_jumping() Your final func handle_movement_state() should now look like this. # Main movement state handler entry point func handle_movement_state (): if movement_state == MovementState . CASTING : handle_casting () elif movement_state == MovementState . AIRBORNE : handle_airborne () else : handle_running () handle_jumping ()","title":"Rinse and repeat!"},{"location":"day-3/#just-2-more-funcs","text":"Create the function set_current_sprite Put the entire block of match (movement_state): in it Invoke it under handle_movement_state() And : Create the function flip_current_sprite Put the entire if-else block of if orientation == Orientation.LEFT: in it Invoke it under set_current_sprite()","title":"Just 2 more funcs!"},{"location":"day-3/#all-tidied-up","text":"Your _physics_process should now look like this: # Changed _process to _physics_process func _physics_process ( delta ): # Apply the gravity. velocity . y += gravity * delta # Set, and handle movement state set_movement_state () handle_movement_state () # Set the correct sprite based on movement state set_current_sprite () # Determine sprite-flip based on orientation flip_current_sprite () # Apply 2d physics engine's movement move_and_slide () And everything should still work. Your entire player.gd script should look like this: player.gd - on github commit: \"use my own tutorial for day-3 part 1.\"","title":"All tidied up"},{"location":"day-3/#technical-debt-5","text":"Two observation on remaining technical debt: Our comments probably do not conform to documentation guidelines Some coding conventions might not comply either Let's park that and go right on ahead to: Day 4 - Casting Fireballs","title":"Technical debt 5"},{"location":"day-4/","text":"Day 4 - Casting Fireballs Today we're going to let Zelia cast fireballs. Want to start from here? Clone or download the result of day 3 from github The steps for today Add a Fireball scene and test its flying Spawn fireballs when she casts Make fireballs collide with the TileMap , not with the Player Generate renditions to make the fireball dissipate Why not shaders? Add a Fireball scene and test its flying We will use a single .png image as a resource for the fireball. You can download it here: assets/fireball.png Adding the fireball image asset and Fireball scene Create a resource dir res://projectiles/fireball Place fireball.png inside Create a new Area2D scene and call it Fireball Save it in res://projectiles/fireball/fireball.tscn Add these child-nodes: AnimatedSprite2D CollisionShape2D Add a SpriteFrames to the AnimatedSprite2D -node Drag the fireball.png into its default animation Use a CircleShape2D for the CollisionShape2D and draw it like this: Although we are using only one image, we are using AnimatedSprite2D , not simply Sprite2D . This is beacause in step 4 we will generate rendition images dynamically for a 'dissipating' animation. Let it fly To make the fireball fly takes a very short script. Attach a script to the fireball scene by right-clicking Scene > Fireball and picking Attach Script from the context menu. Leave the defaults in place, and write the script: extends Area2D # Initialize the fireball with zero speed (x = 0, y = 0) @ export var velocity = Vector2 . ZERO func _physics_process ( delta ): # Update position by velocity-vector position += velocity * delta We exported the velocity -property so we can test this code. Run the current scene by pressing F6 . Wile the scene is running: 1. Go to Scene > Remote > root > Fireball 2. Make sure the game window is visible 3. Find Inspector > Members > Velocity 4. Set x to 50 : This makes the fireball fly out the viewport to the right, never to return. If we're going to spawn hundreds of thousands of them, it will become a dire memory leak. Clean it up To clean up the potential mess, we'll follow some instructions about nodes leaving the viewport from here: Enemy script from: \"My First 2D Game\" : Following these steps, we will now: Add a VisibleOnScreenNotifier2D In the 2D scene view make sure the Rect surrounds the fireball Click on Node next to Inspector Double click Signals > screen_exited() Leave defaults in tact and click Connect Now add this line to the new function _on_visible_on_screen_notifier_2d_screen_exited : func _on_visible_on_screen_notifier_2d_screen_exited (): queue_free () Run the current scene again by pressing F6 and repeat the remote debugging instructions, setting x to 50 Now look at the node-tree under Scene until the fireball exits the game viewport. Congratulations, we deleted it. Spawn fireballs when she casts If you've looked at the original Zelia game , you know that she does not fire on button-press/click, but on fixed intervals while holding a button: Add a FireballIntervalTimer Go to FileSystem > player > player.tscn Add a Timer -node to the Player -node Name it FireballIntervalTimer Go to the Inspector -tab: Set Wait Time to 0.1 Make sure the One Shot -property is checked Off Check On the Autostart -property This makes sure that the FireballIntervalTimer is activated when the Player is instantiated. So, in our current case, when the game starts. Go to the Node -tab (next to Inspector ) Double-click the timeout() -signal Keep the defaults and click Connect So now, let's check if our new listener _on_fireball_interval_timer_timeout() is set up properly: func _on_fireball_interval_timer_timeout (): print ( \"Pow!\" ) Test by pressing F5 , and look at the console: Ok, so the FireballIntervalTimer works, but she should only shoot fireballs when holding the Fireball button : func _on_fireball_interval_timer_timeout (): if movement_state == MovementState . CASTING : rint ( \"Pow!\" ) That's better. Let's shoot the fireballs next. Spawning the fireballs For this section we follow these guides from the godot tutorials: - Instancing - Instancing with signals The main take-away here is to make sure the Fireball -scene is loosely coupled from the Player -scene; it lives a life of its own. This also keeps it testable in isolation, like we did earlier. Add the Fireball scene to the main scene We will however need to be able to access it from the main scene of our game: Open FileSystem > res://world.tscn Connect the Fireball -scene to it by either/or Dragging fireball.tscn from the FileSystem tab into the World -tree Clicking the Instantiate Child Scene button: That made one instance of the Fireball -scene as a direct child of the World -scene. It kinda just sits there, being visible: We can fix that by toggling off visibility here: Declare and invoke a signal to \"cast spells\" What we're doing next is explained in detail in Instancing with signals . We're just going to apply here what we learned. ## top of script # Preload the Fireball class, used to identify it in cast_projectile var Fireball = preload ( \"res://projectiles/fireball/fireball.tscn\" ) # Declare a signal to cast a projectile spell (like Fireball) # in the given direction, from the given origin signal cast_projectile ( spell_class , direction : Vector2 , origin : Vector2 ) ## bottom of script # Spawn a fireball every 100ms if Fireball button is held func _on_fireball_interval_timer_timeout (): if movement_state == MovementState . CASTING : # Signal that a fireball should be cast at casting angle and # from Player's position cast_projectile . emit ( Fireball , cast_angle , position ) Let the world scene listen to the signal The main scene of our game (currently World ) should get a script with a listener to the casting signal. Upon that signal, it must instantiate a new Fireball -node and let it fly: Go to FileSystem > world.tscn Right click the World -node and choose Attach Script Use the defaults and click Create Clear the script to one line: extends TileMap Click on the Player - child-node of World Pick Node next to Inpector Double click cast_projectile(...) Leave defaults to Connect to World Implement _on_player_cast_projectile like this: # world.gd func _on_player_cast_projectile ( spell_class , direction , origin ): var spell = spell_class . instantiate () add_child ( spell ) spell . rotation = direction spell . position = origin spell . velocity = Vector2 . from_angle ( direction ) * 150.0 Test the main scene using F5 NOTE : the fireball should come from her belly in the center at this time. If you made the same mistake I did it might spawn out at another place. FIX : The rootnode Fireball of the fireball.tscn -scene should be in the center of its sprite; it's a subtle grey-plus on the 2D -scene until you click on it. Fix the fireballs' origin, tweak casting sprites with angle of fireball So we don't want Zelia to shoot fire from her belly, but from her hands. This script calculates a new and better origin. # Spawn a fireball every 100ms if Fireball button is held func _on_fireball_interval_timer_timeout (): if movement_state == MovementState . CASTING : # Signal that a fireball should be cast at casting angle and # from Player's hands var origin = position + Vector2 ( 14 , 0 ) . rotated ( cast_angle ) + Vector2 ( 0 , 2 ) cast_projectile . emit ( Fireball , cast_angle , origin ) So the var origin is calculated by applying 3 transformations: 1. Create a 'point' at position x=14, y=0 and rotate it by the casting angle: Vector2(14, 0).rotated(cast_angle) 2. Move it relative to Zelia's center ( position + ) 3. Move it 2 pixels down + Vector(0, 2) Also, her hands do not match up as nicely with the fireballs as they did in the original game. Use these new angles to determine casting_up and casting_down in get_casting_sprite for better effect: var casting_up = deg > - 160 and deg < 0 var casting_down = deg > 30 and deg < 160 Make fireballs collide with the TileMap , not with the Player At the moment fireballs still fly out the game window. We want then to collide with the terrain tiles, however. Let's look at the tutorial once more and apply: Open the fireball scene FileSystem > res://projectiles/fireball/fireball.tscn Select Scene > Fireball Go to Node next to Inspector Double click on the body_entered(body: Node2D) signal Leave defaults on and click Connect To remove them we could use queue_free() again: func _on_body_entered ( body ): queue_free () That works, the fireball collides when it hits the Tilemap . However.. ..It will also disappear if it collides with the Player . Collision Layer and Collision Mask To illustrate, make set its origin the position -property of the player again in player.gd : # comment out the next line with Ctrl+k # var origin = position + Vector2(14, 0).rotated(cast_angle) + Vector2(0, 2) # replace origin with position in next line cast_projectile . emit ( Fireball , cast_angle , position ) Depending on whether the fireballs are drawn over or behind the Player you will see either/or: - them pop in and out of existence - not at all This is because their Collision Mask overlaps the Collision Layer of the player. The answers here explain it nicely: What's the difference between Collision layers and Collision masks? Let's apply what we've learned here like this: - Player : set both mask and layer to 1 (for now) - World > TileSet : set both mask and layer to 1 and 2 (for now) - Fireball : set both mask and layer to 2 (for now) Player is already set correctly. However, we might want more granularity later. Setting Collision Layer and Collision Mask for Fireball This is a set of properties most easily manipulated in the Inpector . Select res://projectiles/fireball/fireball.tscn Click on the Fireball node Go to Inspector > Collision set both mask and layer to 2 (for now) Setting it for World But to set it for the World scene, be aware you also need to click on Inspector > Tile Set > TileSet > Physics Layers as it is a property not of the TileMap , but of (one of) its TileSet (s)' Physics Layer (s) --> if you can still follow. Test again Press F5 to test if the fireballs do collide with the Tilemap and do not collide with the Player . Then change back the player.gd script: var origin = position + Vector2 ( 14 , 0 ) . rotated ( cast_angle ) + Vector2 ( 0 , 2 ) cast_projectile . emit ( Fireball , cast_angle , origin ) Add some smoothness to the collided fireballs Right now the fireballs disappear very abrubtly because queue_free() is invoked immediately. We can smoothe this out a little by introducing a delay and slowing them down on impact: Go to fireball.tscn Give it a Timer child node and call it DissipateTimer Check Inspector > One Shot to On Set the Wait Time to 0.5 Change+Add this script to fireball.gd : func _on_body_entered ( body ): # start the new timer in stead of calling queue_free here $ DissipateTimer . start () # slow it down to 1/10th the speed velocity *= 0.1 Click DissipateTimer -node Connect the Node > timeout() -signal to the Fireball Implement _on_dissipate_timer_timeout() like so: func _on_dissipate_timer_timeout (): queue_free () That's only a little better. We need an animation to make them fade into non-existence slowly. Generate renditions to make the fireball dissipate We could make this very ease on ourselves by drawing images manually in our favourite image manipulation program , but we'll do it the lazy way. Well, that is to say, the programmer's way, a.k.a. the reusable way. Remembering the original game we see a lot of stuff disappear in the same, lazy, reused way. We want to know how, right? Using Autoload for preprocessing So looking at the documentation it becomes clear that you can easily manipulate texture images using these two classes: - Image - ImageTexture But what is less evident is how to do it only one time, in stead of all the 100.000 + times a fireball collides. That would not perform at all . Luckily, when you search the docs for \" Singleton \" (my fifth attempt) you find the Autoload -class, which is meant for precisely this: Singletons (Autoload) So, let us apply the steps and the test if we set it up properly. Go to Project > Project Settings > Autoload (4th tab) Click on the Node Name input Type in TextureRenditions , which will be the name of our first Autoload Click Add In the dialog, leave the defaults, creating a new script res://texture_renditions.gd Leave the Global Variable -checkbox check on to Enable Close the Project Settings -dialog again. Enter this test script in the file texture_renditions.gd : extends Node var singleton_test : String func _ready (): singleton_test = \"singleton_test\" print ( \"asserting this print is called only once\" ) Run the project with F5 and confirm in the console that yes indeed: asserting this print is called only once --- Debugging process stopped --- Also, test if TextureRenditions.singleton_test is indeed a globally accessible string in fireball.gd : func _ready (): print ( TextureRenditions . singleton_test ) Run the project again and confirm in the console after shooting some fireballs: singleton_test singleton_test singleton_test singleton_test --- Debugging process stopped --- Generate the dissipate animation with Image and ImageTexture So now we want to prepare the animation for the fireball in our Autoload -node called TextureRenditions . Open the texture_renditions.gd script again. Use preload to open the fireball.png texture and get an instance of its Image : extends Node var fireball = preload ( \"res://projectiles/fireball/fireball.png\" ) . get_image () Prepare a global array to hold the preprocess images: var fireball_dissipate : Array = [] In the _ready() function add this line: func _ready (): fireball_dissipate = get_dissipate_renditions ( fireball ) And then write the function get_dissipate_renditions(...) # Test if we can make one gray fireball first func get_dissipate_renditions ( src_rendition ): # Create a new Image instance with the same properties as the source image var dst_rendition = Image . create ( src_rendition . get_width (), src_rendition . get_height (), false , src_rendition . get_format ()) # Loop through all the pixels for x in range ( src_rendition . get_width ()): for y in range ( src_rendition . get_height ()): # Get the original color var src_color = src_rendition . get_pixel ( x , y ) # Set red, green and blue to the red of the source color # and keep the source alpha transparency dst_rendition . set_pixel ( x , y , Color ( src_color . r , src_color . r , src_color . r , src_color . a )) # return a list of one gray-scaled image rendition # converted to an instace of ImageTexture return [ ImageTexture . create_from_image ( dst_rendition )] Now edit fireball.gd , edit _ready() like this: func _ready (): # Start playing the \"default\" animation $ AnimatedSprite2D . play ( \"default\" ) # The sprite_frames of $AnimatedSprite2D is a singleton, so after calling # add_animation one time, it exists for all other instances if \"dissipate\" not in $ AnimatedSprite2D . sprite_frames . get_animation_names (): # Add a new animation to the SpriteFrames instance of the $AnimatedSprite2D node $ AnimatedSprite2D . sprite_frames . add_animation ( \"dissipate\" ) # Loop through all rendition images in the global singleton fireball_dissipate for rendition in TextureRenditions . fireball_dissipate : # Add them as a frame to $ AnimatedSprite2D . sprite_frames . add_frame ( \"dissipate\" , rendition ) And change the animation on impact in _on_body_entered : func _on_body_entered ( body ): # play the dissipate animation we coded $ AnimatedSprite2D . play ( \"dissipate\" ) # start the new timer in stead of calling queue_free here $ DissipateTimer . start () # slow it down to 1/10th the speed velocity *= 0.1 Test the project with F5 . You should now see gray fireballs after collision: The actual rendition script Now that we established a simple list of one gray fireball rendition worked, let's finish up the rendition script in texture_renditions.gd : func _ready (): fireball_dissipate = get_dissipate_renditions ( fireball , 30 , 1 , 0.25 ) # Return a list of dissipating image renditions as an ImageTexture-Array # - src_rendition is the original Image # - amount is the amount of times to repeat the rendition effect # - scatter is the chance of a pixel being rendered again in a given rendeition # - fade is the factor by which the alpha channel transparency should be reduced # in each rendition func get_dissipate_renditions ( src_rendition : Image , amount : int = 14 , scatter : int = 1 , fade : float = 0.5 ): var renditions = [] for n in range ( amount ): # Create a new Image instance with the same properties as the source image var dst_rendition = Image . create ( src_rendition . get_width (), src_rendition . get_height (), false , src_rendition . get_format ()) # Loop through all the pixels for x in range ( src_rendition . get_width ()): for y in range ( src_rendition . get_height ()): # Get the original color var src_color = src_rendition . get_pixel ( x , y ) # Copy the source pixel if the random int between 0 and scatter # hits one if randi_range ( 0 , scatter ) == 1 : # Copy the pixel, reduce opacity by factor fade dst_rendition . set_pixel ( x , y , Color ( src_color . r , src_color . g , src_color . b , src_color . a * fade )) # append this rendition to result array renditions . append ( ImageTexture . create_from_image ( dst_rendition )) # overwrite the src_rendition variable with a new empty image src_rendition = Image . create ( src_rendition . get_width (), src_rendition . get_height (), false , src_rendition . get_format ()) # copy the current rendition into this variable entirely to be # manipulated in the next iteration src_rendition . copy_from ( dst_rendition ) # return the list of amount renditions return renditions Upon testing with F5 , we should now see something like this: Tastes may differ, but personally I enjoy the fact that the random scatter in our renditions makes the fireball dissipate a little differently every time we play the game. Final touch: show behind parent The fireball looks nicer if it's not drawn over the tiles (nor anything else). Drawing it behind the tiles ( and everything else) makes it look like it really burns the target a little. There is a checkbox for that as well! Open the Fireball scene Click the Fireball -node Open the Inspector Check the Visibility > Show Behind Parent -property to On This works because in our main scene, World , the TileMap is the parent node of the Fireball -instances. Test again: Why not shaders? So, I also tried 2D shaders of the canvas_item type. But my first attempt failed. You can see my attempt in this branch: Failed shader attempt on github So the (common) mistake I made was assuming that a shader script would be active on the instance of a fireball, so I attached it to the material of a Sprite2D . But that is not supported yet What would probably work is to make a hardcoded \"dissipate\" in our $AnimatedSprite2D.SpriteSet and invoke the script i have from there. Another thing is the display setting I chose: it mimics pixels, but just look at the picture just above here: it is perfectly rotated (like Mario Maker 2 seesaws). That makes shaders High Resolution. Tomorrow we should dive into shaders!","title":"Day 4 - Casting Fireballs"},{"location":"day-4/#day-4-casting-fireballs","text":"Today we're going to let Zelia cast fireballs. Want to start from here? Clone or download the result of day 3 from github","title":"Day 4 - Casting Fireballs"},{"location":"day-4/#the-steps-for-today","text":"Add a Fireball scene and test its flying Spawn fireballs when she casts Make fireballs collide with the TileMap , not with the Player Generate renditions to make the fireball dissipate Why not shaders?","title":"The steps for today"},{"location":"day-4/#add-a-fireball-scene-and-test-its-flying","text":"We will use a single .png image as a resource for the fireball. You can download it here: assets/fireball.png","title":"Add a Fireball scene and test its flying"},{"location":"day-4/#adding-the-fireball-image-asset-and-fireball-scene","text":"Create a resource dir res://projectiles/fireball Place fireball.png inside Create a new Area2D scene and call it Fireball Save it in res://projectiles/fireball/fireball.tscn Add these child-nodes: AnimatedSprite2D CollisionShape2D Add a SpriteFrames to the AnimatedSprite2D -node Drag the fireball.png into its default animation Use a CircleShape2D for the CollisionShape2D and draw it like this: Although we are using only one image, we are using AnimatedSprite2D , not simply Sprite2D . This is beacause in step 4 we will generate rendition images dynamically for a 'dissipating' animation.","title":"Adding the fireball image asset and Fireball scene"},{"location":"day-4/#let-it-fly","text":"To make the fireball fly takes a very short script. Attach a script to the fireball scene by right-clicking Scene > Fireball and picking Attach Script from the context menu. Leave the defaults in place, and write the script: extends Area2D # Initialize the fireball with zero speed (x = 0, y = 0) @ export var velocity = Vector2 . ZERO func _physics_process ( delta ): # Update position by velocity-vector position += velocity * delta We exported the velocity -property so we can test this code. Run the current scene by pressing F6 . Wile the scene is running: 1. Go to Scene > Remote > root > Fireball 2. Make sure the game window is visible 3. Find Inspector > Members > Velocity 4. Set x to 50 : This makes the fireball fly out the viewport to the right, never to return. If we're going to spawn hundreds of thousands of them, it will become a dire memory leak.","title":"Let it fly"},{"location":"day-4/#clean-it-up","text":"To clean up the potential mess, we'll follow some instructions about nodes leaving the viewport from here: Enemy script from: \"My First 2D Game\" : Following these steps, we will now: Add a VisibleOnScreenNotifier2D In the 2D scene view make sure the Rect surrounds the fireball Click on Node next to Inspector Double click Signals > screen_exited() Leave defaults in tact and click Connect Now add this line to the new function _on_visible_on_screen_notifier_2d_screen_exited : func _on_visible_on_screen_notifier_2d_screen_exited (): queue_free () Run the current scene again by pressing F6 and repeat the remote debugging instructions, setting x to 50 Now look at the node-tree under Scene until the fireball exits the game viewport. Congratulations, we deleted it.","title":"Clean it up"},{"location":"day-4/#spawn-fireballs-when-she-casts","text":"If you've looked at the original Zelia game , you know that she does not fire on button-press/click, but on fixed intervals while holding a button:","title":"Spawn fireballs when she casts"},{"location":"day-4/#add-a-fireballintervaltimer","text":"Go to FileSystem > player > player.tscn Add a Timer -node to the Player -node Name it FireballIntervalTimer Go to the Inspector -tab: Set Wait Time to 0.1 Make sure the One Shot -property is checked Off Check On the Autostart -property This makes sure that the FireballIntervalTimer is activated when the Player is instantiated. So, in our current case, when the game starts. Go to the Node -tab (next to Inspector ) Double-click the timeout() -signal Keep the defaults and click Connect So now, let's check if our new listener _on_fireball_interval_timer_timeout() is set up properly: func _on_fireball_interval_timer_timeout (): print ( \"Pow!\" ) Test by pressing F5 , and look at the console: Ok, so the FireballIntervalTimer works, but she should only shoot fireballs when holding the Fireball button : func _on_fireball_interval_timer_timeout (): if movement_state == MovementState . CASTING : rint ( \"Pow!\" ) That's better. Let's shoot the fireballs next.","title":"Add a FireballIntervalTimer"},{"location":"day-4/#spawning-the-fireballs","text":"For this section we follow these guides from the godot tutorials: - Instancing - Instancing with signals The main take-away here is to make sure the Fireball -scene is loosely coupled from the Player -scene; it lives a life of its own. This also keeps it testable in isolation, like we did earlier.","title":"Spawning the fireballs"},{"location":"day-4/#add-the-fireball-scene-to-the-main-scene","text":"We will however need to be able to access it from the main scene of our game: Open FileSystem > res://world.tscn Connect the Fireball -scene to it by either/or Dragging fireball.tscn from the FileSystem tab into the World -tree Clicking the Instantiate Child Scene button: That made one instance of the Fireball -scene as a direct child of the World -scene. It kinda just sits there, being visible: We can fix that by toggling off visibility here:","title":"Add the Fireball scene to the main scene"},{"location":"day-4/#declare-and-invoke-a-signal-to-cast-spells","text":"What we're doing next is explained in detail in Instancing with signals . We're just going to apply here what we learned. ## top of script # Preload the Fireball class, used to identify it in cast_projectile var Fireball = preload ( \"res://projectiles/fireball/fireball.tscn\" ) # Declare a signal to cast a projectile spell (like Fireball) # in the given direction, from the given origin signal cast_projectile ( spell_class , direction : Vector2 , origin : Vector2 ) ## bottom of script # Spawn a fireball every 100ms if Fireball button is held func _on_fireball_interval_timer_timeout (): if movement_state == MovementState . CASTING : # Signal that a fireball should be cast at casting angle and # from Player's position cast_projectile . emit ( Fireball , cast_angle , position )","title":"Declare and invoke a signal to \"cast spells\""},{"location":"day-4/#let-the-world-scene-listen-to-the-signal","text":"The main scene of our game (currently World ) should get a script with a listener to the casting signal. Upon that signal, it must instantiate a new Fireball -node and let it fly: Go to FileSystem > world.tscn Right click the World -node and choose Attach Script Use the defaults and click Create Clear the script to one line: extends TileMap Click on the Player - child-node of World Pick Node next to Inpector Double click cast_projectile(...) Leave defaults to Connect to World Implement _on_player_cast_projectile like this: # world.gd func _on_player_cast_projectile ( spell_class , direction , origin ): var spell = spell_class . instantiate () add_child ( spell ) spell . rotation = direction spell . position = origin spell . velocity = Vector2 . from_angle ( direction ) * 150.0 Test the main scene using F5 NOTE : the fireball should come from her belly in the center at this time. If you made the same mistake I did it might spawn out at another place. FIX : The rootnode Fireball of the fireball.tscn -scene should be in the center of its sprite; it's a subtle grey-plus on the 2D -scene until you click on it.","title":"Let the world scene listen to the signal"},{"location":"day-4/#fix-the-fireballs-origin-tweak-casting-sprites-with-angle-of-fireball","text":"So we don't want Zelia to shoot fire from her belly, but from her hands. This script calculates a new and better origin. # Spawn a fireball every 100ms if Fireball button is held func _on_fireball_interval_timer_timeout (): if movement_state == MovementState . CASTING : # Signal that a fireball should be cast at casting angle and # from Player's hands var origin = position + Vector2 ( 14 , 0 ) . rotated ( cast_angle ) + Vector2 ( 0 , 2 ) cast_projectile . emit ( Fireball , cast_angle , origin ) So the var origin is calculated by applying 3 transformations: 1. Create a 'point' at position x=14, y=0 and rotate it by the casting angle: Vector2(14, 0).rotated(cast_angle) 2. Move it relative to Zelia's center ( position + ) 3. Move it 2 pixels down + Vector(0, 2) Also, her hands do not match up as nicely with the fireballs as they did in the original game. Use these new angles to determine casting_up and casting_down in get_casting_sprite for better effect: var casting_up = deg > - 160 and deg < 0 var casting_down = deg > 30 and deg < 160","title":"Fix the fireballs' origin, tweak casting sprites with angle of fireball"},{"location":"day-4/#make-fireballs-collide-with-the-tilemap-not-with-the-player","text":"At the moment fireballs still fly out the game window. We want then to collide with the terrain tiles, however. Let's look at the tutorial once more and apply: Open the fireball scene FileSystem > res://projectiles/fireball/fireball.tscn Select Scene > Fireball Go to Node next to Inspector Double click on the body_entered(body: Node2D) signal Leave defaults on and click Connect To remove them we could use queue_free() again: func _on_body_entered ( body ): queue_free () That works, the fireball collides when it hits the Tilemap . However.. ..It will also disappear if it collides with the Player .","title":"Make fireballs collide with the TileMap, not with the Player"},{"location":"day-4/#collision-layer-and-collision-mask","text":"To illustrate, make set its origin the position -property of the player again in player.gd : # comment out the next line with Ctrl+k # var origin = position + Vector2(14, 0).rotated(cast_angle) + Vector2(0, 2) # replace origin with position in next line cast_projectile . emit ( Fireball , cast_angle , position ) Depending on whether the fireballs are drawn over or behind the Player you will see either/or: - them pop in and out of existence - not at all This is because their Collision Mask overlaps the Collision Layer of the player. The answers here explain it nicely: What's the difference between Collision layers and Collision masks? Let's apply what we've learned here like this: - Player : set both mask and layer to 1 (for now) - World > TileSet : set both mask and layer to 1 and 2 (for now) - Fireball : set both mask and layer to 2 (for now) Player is already set correctly. However, we might want more granularity later.","title":"Collision Layer and Collision Mask"},{"location":"day-4/#setting-collision-layer-and-collision-mask-for-fireball","text":"This is a set of properties most easily manipulated in the Inpector . Select res://projectiles/fireball/fireball.tscn Click on the Fireball node Go to Inspector > Collision set both mask and layer to 2 (for now)","title":"Setting Collision Layer and Collision Mask for Fireball"},{"location":"day-4/#setting-it-for-world","text":"But to set it for the World scene, be aware you also need to click on Inspector > Tile Set > TileSet > Physics Layers as it is a property not of the TileMap , but of (one of) its TileSet (s)' Physics Layer (s) --> if you can still follow.","title":"Setting it for World"},{"location":"day-4/#test-again","text":"Press F5 to test if the fireballs do collide with the Tilemap and do not collide with the Player . Then change back the player.gd script: var origin = position + Vector2 ( 14 , 0 ) . rotated ( cast_angle ) + Vector2 ( 0 , 2 ) cast_projectile . emit ( Fireball , cast_angle , origin )","title":"Test again"},{"location":"day-4/#add-some-smoothness-to-the-collided-fireballs","text":"Right now the fireballs disappear very abrubtly because queue_free() is invoked immediately. We can smoothe this out a little by introducing a delay and slowing them down on impact: Go to fireball.tscn Give it a Timer child node and call it DissipateTimer Check Inspector > One Shot to On Set the Wait Time to 0.5 Change+Add this script to fireball.gd : func _on_body_entered ( body ): # start the new timer in stead of calling queue_free here $ DissipateTimer . start () # slow it down to 1/10th the speed velocity *= 0.1 Click DissipateTimer -node Connect the Node > timeout() -signal to the Fireball Implement _on_dissipate_timer_timeout() like so: func _on_dissipate_timer_timeout (): queue_free () That's only a little better. We need an animation to make them fade into non-existence slowly.","title":"Add some smoothness to the collided fireballs"},{"location":"day-4/#generate-renditions-to-make-the-fireball-dissipate","text":"We could make this very ease on ourselves by drawing images manually in our favourite image manipulation program , but we'll do it the lazy way. Well, that is to say, the programmer's way, a.k.a. the reusable way. Remembering the original game we see a lot of stuff disappear in the same, lazy, reused way. We want to know how, right?","title":"Generate renditions to make the fireball dissipate"},{"location":"day-4/#using-autoload-for-preprocessing","text":"So looking at the documentation it becomes clear that you can easily manipulate texture images using these two classes: - Image - ImageTexture But what is less evident is how to do it only one time, in stead of all the 100.000 + times a fireball collides. That would not perform at all . Luckily, when you search the docs for \" Singleton \" (my fifth attempt) you find the Autoload -class, which is meant for precisely this: Singletons (Autoload) So, let us apply the steps and the test if we set it up properly. Go to Project > Project Settings > Autoload (4th tab) Click on the Node Name input Type in TextureRenditions , which will be the name of our first Autoload Click Add In the dialog, leave the defaults, creating a new script res://texture_renditions.gd Leave the Global Variable -checkbox check on to Enable Close the Project Settings -dialog again. Enter this test script in the file texture_renditions.gd : extends Node var singleton_test : String func _ready (): singleton_test = \"singleton_test\" print ( \"asserting this print is called only once\" ) Run the project with F5 and confirm in the console that yes indeed: asserting this print is called only once --- Debugging process stopped --- Also, test if TextureRenditions.singleton_test is indeed a globally accessible string in fireball.gd : func _ready (): print ( TextureRenditions . singleton_test ) Run the project again and confirm in the console after shooting some fireballs: singleton_test singleton_test singleton_test singleton_test --- Debugging process stopped ---","title":"Using Autoload for preprocessing"},{"location":"day-4/#generate-the-dissipate-animation-with-image-and-imagetexture","text":"So now we want to prepare the animation for the fireball in our Autoload -node called TextureRenditions . Open the texture_renditions.gd script again. Use preload to open the fireball.png texture and get an instance of its Image : extends Node var fireball = preload ( \"res://projectiles/fireball/fireball.png\" ) . get_image () Prepare a global array to hold the preprocess images: var fireball_dissipate : Array = [] In the _ready() function add this line: func _ready (): fireball_dissipate = get_dissipate_renditions ( fireball ) And then write the function get_dissipate_renditions(...) # Test if we can make one gray fireball first func get_dissipate_renditions ( src_rendition ): # Create a new Image instance with the same properties as the source image var dst_rendition = Image . create ( src_rendition . get_width (), src_rendition . get_height (), false , src_rendition . get_format ()) # Loop through all the pixels for x in range ( src_rendition . get_width ()): for y in range ( src_rendition . get_height ()): # Get the original color var src_color = src_rendition . get_pixel ( x , y ) # Set red, green and blue to the red of the source color # and keep the source alpha transparency dst_rendition . set_pixel ( x , y , Color ( src_color . r , src_color . r , src_color . r , src_color . a )) # return a list of one gray-scaled image rendition # converted to an instace of ImageTexture return [ ImageTexture . create_from_image ( dst_rendition )] Now edit fireball.gd , edit _ready() like this: func _ready (): # Start playing the \"default\" animation $ AnimatedSprite2D . play ( \"default\" ) # The sprite_frames of $AnimatedSprite2D is a singleton, so after calling # add_animation one time, it exists for all other instances if \"dissipate\" not in $ AnimatedSprite2D . sprite_frames . get_animation_names (): # Add a new animation to the SpriteFrames instance of the $AnimatedSprite2D node $ AnimatedSprite2D . sprite_frames . add_animation ( \"dissipate\" ) # Loop through all rendition images in the global singleton fireball_dissipate for rendition in TextureRenditions . fireball_dissipate : # Add them as a frame to $ AnimatedSprite2D . sprite_frames . add_frame ( \"dissipate\" , rendition ) And change the animation on impact in _on_body_entered : func _on_body_entered ( body ): # play the dissipate animation we coded $ AnimatedSprite2D . play ( \"dissipate\" ) # start the new timer in stead of calling queue_free here $ DissipateTimer . start () # slow it down to 1/10th the speed velocity *= 0.1 Test the project with F5 . You should now see gray fireballs after collision:","title":"Generate the dissipate animation with Image and ImageTexture"},{"location":"day-4/#the-actual-rendition-script","text":"Now that we established a simple list of one gray fireball rendition worked, let's finish up the rendition script in texture_renditions.gd : func _ready (): fireball_dissipate = get_dissipate_renditions ( fireball , 30 , 1 , 0.25 ) # Return a list of dissipating image renditions as an ImageTexture-Array # - src_rendition is the original Image # - amount is the amount of times to repeat the rendition effect # - scatter is the chance of a pixel being rendered again in a given rendeition # - fade is the factor by which the alpha channel transparency should be reduced # in each rendition func get_dissipate_renditions ( src_rendition : Image , amount : int = 14 , scatter : int = 1 , fade : float = 0.5 ): var renditions = [] for n in range ( amount ): # Create a new Image instance with the same properties as the source image var dst_rendition = Image . create ( src_rendition . get_width (), src_rendition . get_height (), false , src_rendition . get_format ()) # Loop through all the pixels for x in range ( src_rendition . get_width ()): for y in range ( src_rendition . get_height ()): # Get the original color var src_color = src_rendition . get_pixel ( x , y ) # Copy the source pixel if the random int between 0 and scatter # hits one if randi_range ( 0 , scatter ) == 1 : # Copy the pixel, reduce opacity by factor fade dst_rendition . set_pixel ( x , y , Color ( src_color . r , src_color . g , src_color . b , src_color . a * fade )) # append this rendition to result array renditions . append ( ImageTexture . create_from_image ( dst_rendition )) # overwrite the src_rendition variable with a new empty image src_rendition = Image . create ( src_rendition . get_width (), src_rendition . get_height (), false , src_rendition . get_format ()) # copy the current rendition into this variable entirely to be # manipulated in the next iteration src_rendition . copy_from ( dst_rendition ) # return the list of amount renditions return renditions Upon testing with F5 , we should now see something like this: Tastes may differ, but personally I enjoy the fact that the random scatter in our renditions makes the fireball dissipate a little differently every time we play the game.","title":"The actual rendition script"},{"location":"day-4/#final-touch-show-behind-parent","text":"The fireball looks nicer if it's not drawn over the tiles (nor anything else). Drawing it behind the tiles ( and everything else) makes it look like it really burns the target a little. There is a checkbox for that as well! Open the Fireball scene Click the Fireball -node Open the Inspector Check the Visibility > Show Behind Parent -property to On This works because in our main scene, World , the TileMap is the parent node of the Fireball -instances. Test again:","title":"Final touch: show behind parent"},{"location":"day-4/#why-not-shaders","text":"So, I also tried 2D shaders of the canvas_item type. But my first attempt failed. You can see my attempt in this branch: Failed shader attempt on github So the (common) mistake I made was assuming that a shader script would be active on the instance of a fireball, so I attached it to the material of a Sprite2D . But that is not supported yet What would probably work is to make a hardcoded \"dissipate\" in our $AnimatedSprite2D.SpriteSet and invoke the script i have from there. Another thing is the display setting I chose: it mimics pixels, but just look at the picture just above here: it is perfectly rotated (like Mario Maker 2 seesaws). That makes shaders High Resolution. Tomorrow we should dive into shaders!","title":"Why not shaders?"},{"location":"day-5/","text":"Day 5 - Slimes, Breaking tiles, Falling Tiles, Scenery Tiles and Shaders A long title for a long episode! What we'll do today Make a bouncing Slime monster Add the tree-trunk terrain Make tiles Zelia can break Allow those breakable tiles to fall down Technical Debt 6 Reuse tiles as background scenery Make a bouncing Slime monster Every game needs one. Setting up the slime scene Download the zip: assets/green-slime.zip Create the resource dirs res://monsters/slime/green Extract the .png files in that res://monsters/slime/green dir Create a new CharacterBody2D -scene Rename it to Slime And save it into res://monsters/slime/slime.tscn Give slime a child node AnimatedSprite2D Navigate to its Inspector Sprite Frames > SpriteFrame > Animations Change default into airborne , add slime/green/5.png to it Add floor_bounce and add 1.png - 4.png to that -> in that order Set floor_bounce to 7 fps for the nicest effect: Add 2 collision shapes Because our slime looks a little different depending on what state it's in, let's give it 2 collision shapes: Add a child CollisionShape2D -node to Scene > Slime Name it: AirborneCollisionShape Pick CircleShape2D under Inspector > Shape Align it nicely around the airborne animation sprite: Next: 1. Add another child CollisionShape2D -node to Scene > Slime 2. Name it: FloorBounceCollisionShape 3. Pick CapsuleShape2D under Inspector > Shape 4. Align it around the first floor_bounce animation sprite: Setting up the slime.gd script Add the slime to the main scene: Open res://world.tscn Drag at least one slime scene res://monsters/slimes/slime.tscn into the World -scene Test the main scene World with F5 and observe that the slime hangs there doing nothing: Open the res://monsters/slimes/slime.tscn scene Attach a script to it, picking the default values in the dialog You might notice a lot of suggested code for a CharacterBody2D - although it could be fun to try it out, it's not what we're looking for. Remove all code and replace the _physics_process function body with pass : extends CharacterBody2D func _physics_process ( delta ): pass Adding the MovementState s We have 2 animations currently, so let's create 2 movement states to match: extends CharacterBody2D enum MovementState { AIRBORNE , FLOOR_BOUNCE } var movement_state : int func _ready (): # assume it starts out hanging in the air movement_state = MovementState . AIRBORNE # start up the correct animated sprite sprite frames for that state $ AnimatedSprite2D . animation = \"airborne\" $ AnimatedSprite2D . play () We also know the slime must bounce around. We can use some familiar stuff for that: # We want the level designer to be able to modify stuff like this. @ export var JUMP_VELOCITY = - 400.0 var gravity = ProjectSettings . get_setting ( \"physics/2d/default_gravity\" ) Now let's at the very least allow some move_and_slide() in the _physics_process , applying the gravity: func _physics_process ( delta ): velocity . y += gravity * delta move_and_slide () Now test again ith F5 - the slime falls down and lands on the tiles. Picking the right collision shape As we saw when we were setting up the scene, the slime has 2 CollisionShapes2D s attached of which only one should be active at a time, base on its movement_state . Create a func pick_collision_shape_for_movement_state : # enable the collision shape that matches the current movement state func pick_collision_shape_for_movement_state (): match ( movement_state ): MovementState . AIRBORNE : $ AirborneCollisionShape . disabled = false $ FloorBounceCollisionShape . disabled = true MovementState . FLOOR_BOUNCE : $ AirborneCollisionShape . disabled = true $ FloorBounceCollisionShape . disabled = false And make sure to invoke it once the slime is instantiated: func _ready (): # assume it starts out hanging in the air movement_state = MovementState . AIRBORNE # enable the collision shape that matches the movement state pick_collision_shape_for_movement_state () Setting the right movement state in the _physics_process When we programmed the player (hacked it together the 1st time) we had to do a lot of refactor work early on to make the player.gd code more understandable and maintainable. The most important step we took was to separate out two stages in the _physics_process to determine what the player should do in this iteration (this time around in the infinite loop): 1. set_movement_state() 2. handle_movement_state() Even though it felt artificial to force such a hard separation in 2 functions, it made some code that is easier for a human (like us, I hope) to reason about. Let's reapply it here, so first create the 2 new empty functions set_movement_state and handle_movement_state and invoke them from _physics_process , right after the gravity is applied: func _physics_process ( delta ): # Apply gravity velocity . y += gravity * delta # Set, and handle movement state set_movement_state () handle_movement_state () move_and_slide () Programming the full slime behaviour in steps Now we will reason our way to a working, bouncing slime. Coding it in small steps: Make the slime bounce up and down Make the slime bounce in the direction of the player Make the slime take damage from fireballs Allow the slime to die from damage Make the slime hurt the player by bouncing into the player Make the slime bounce up and down Let's start out by making it land nicely. So we set the correct movement state and animated sprite when the slime is on the floor: func set_movement_state (): if is_on_floor (): movement_state = MovementState . FLOOR_BOUNCE pick_collision_shape_for_movement_state () $ AnimatedSprite2D . animation = \"floor_bounce\" Test using F5 . The next step is to make it bounce up again round about when the \"floor_bounce\" animation finishes. We'll need a one-shot timer for that and we need to start it at the right moment: Go to Scene > Slime and add a child node Timer Rename it to FloorBounceTimer Make sure One Shot is check to On under Inspector Set its Wait Time to 0.571s \"Why 0.571s ,\" you say? Well, it's 7fps times 4 animation frames: 1 / 7 * 4 . Go to Node > Timer and double-click timeout() Keep the defaults and attach it to the Slime 's script So this is the moment we want the slime to jump up again, let's write: func start_jump (): velocity . y = JUMP_VELOCITY func _on_floor_bounce_timer_timeout (): start_jump () We also need to start the timer when we know the slime has landed: func set_movement_state (): if is_on_floor (): # place this new code _before_ changing the movement_state! # so only start the timer at the moment of _landing_ if movement_state == MovementState . AIRBORNE : $ FloorBounceTimer . start () movement_state = MovementState . FLOOR_BOUNCE pick_collision_shape_for_movement_state () $ AnimatedSprite2D . animation = \"floor_bounce\" Test with F5 : it only flies up once and it looks off. We're still missing something! We need to set the correct movement state, animation and collision shape for when is_on_floor() is false : func set_movement_state (): if is_on_floor (): # ... leave the same ... else : movement_state = MovementState . AIRBORNE pick_collision_shape_for_movement_state () $ AnimatedSprite2D . animation = \"airborne\" Test with F5 : that looks a lot better Refactor early. The code is cluttering up already. Also, we have not made use of our somewhat artificial separation between set_movement_state and handle_movement_state yet. That separation was supposed to make the code easier to reason about, So now apply the following early ' incisions ' >:) Move the code that is more about handling the current movement_state to the function handle_movement_state : func handle_movement_state (): pick_collision_shape_for_movement_state () # pick the animation sprite for the current movement state match ( movement_state ): MovementState . FLOOR_BOUNCE : $ AnimatedSprite2D . animation = \"floor_bounce\" MovementState . AIRBORNE : $ AnimatedSprite2D . animation = \"airborne\" Now you can remove a lot of code from set_movement_state , leaving only the stuff that is more about setting a new movement_state : func set_movement_state (): if is_on_floor (): if movement_state == MovementState . AIRBORNE : $ FloorBounceTimer . start () movement_state = MovementState . FLOOR_BOUNCE else : movement_state = MovementState . AIRBORNE We still have a match -block that needs a comment to explain what it does. Let's fix that by creating a function for it: func pick_sprite_for_movement_state (): match ( movement_state ): MovementState . FLOOR_BOUNCE : $ AnimatedSprite2D . animation = \"floor_bounce\" MovementState . AIRBORNE : $ AnimatedSprite2D . animation = \"airborne\" And invoke it from handle_movement_state like so: func handle_movement_state (): pick_collision_shape_for_movement_state () pick_sprite_for_movement_state () Did you notice we applied the lesson we learned on day 3 about refactoring big functions ? Make the slime bounce in the direction of the player So, now that the slimes are bouncing up and down nicely, we need to make them aware of where their only enemy is: you , the player. So we already learned a surefire approach through using singletons (or Autoload ) on day 4 . Let's apply that again: Go to Project > Project Settings... > Autoload Fill in PlayerState under Node Name and click Add In the dialog keep the defaults and create the new file Open res://player_state.gd Add a var position of type Vector2 When _ready initialize it with Vector2.ZERO : extends Node var position : Vector2 func _ready (): position = Vector2 . ZERO Updating PlayerState.position Now this new PlayerState singleton must be updated at least every time the player moves. Do this by adding this one line to a suitable function in player.gd : func _process ( _delta ) PlayerState . position = position Using PlayerState.position in slime.gd Now the slime can't fly, so the only property we need to update in slime.gd is the x-position. The effect we want to achieve is that the slime only moves on the x-axis when airborne. That makes sense because slimes are sticky and do not slide around while stuck to the floor. So the moment that we want to decide its velocity.x is when its jump starts and the moment that we want to stop x movement is when it lands. Go script it: @ export var X_VELOCITY = 100 func start_jump (): velocity . y = JUMP_VELOCITY if PlayerState . position . x < position . x : velocity . x = - X_VELOCITY else : velocity . x = X_VELOCITY func set_movement_state (): if is_on_floor (): if movement_state == MovementState . AIRBORNE : # new line: velocity . x = 0 $ FloorBounceTimer . start () movement_state = MovementState . FLOOR_BOUNCE else : movement_state = MovementState . AIRBORNE Now press F5 and test: The first jump looks great, but the second jump already has an issue. So apparently, when the slime hits a wall, the velocity.x is set to zero by move_and_slide() ... Sounds like it makes perfect sense. But we want it to fly left to reach te player, so we're going to fight this resistance! :D. We'll pick our battle with physics right here: func handle_movement_state (): # keep trying to reach the player, even when bumping against the wall if is_on_wall (): if PlayerState . position . x < position . x : velocity . x = - X_VELOCITY else : velocity . x = X_VELOCITY pick_collision_shape_for_movement_state () pick_sprite_for_movement_state () Refactor early part 2 So I'm often a lone programmer, which is bad . One rule of thumb I learned concerning the DRY (Don't Repeat Yourself) principle I learned - when I did work in a team - is: if you see the same snippet of code duplicated 3 times, refactor. Well, I'm annoyed seeing it just 2 times right now, so let's fix it early : func follow_player (): if PlayerState . position . x < position . x : velocity . x = - X_VELOCITY else : velocity . x = X_VELOCITY Invoke it in handle_movement_state and start_jump. . Now your code is DRY again. Make the slime take damage from fireballs When a fireball hits a slime we can detect it, but which of the two should detect the collision? Turns out we'll be handling this one, reasoning from the fireball. Which makes sense. The fireball will know how much punch it packs and it will deal it to anything that can take_damage(...) . So the first thing we will do is implement that method for the slime: @ export var hp = 10 func take_damage ( dmg : int ): hp -= dmg # test if it works print ( \"Ouch! hp = \" + str ( hp )) Now add the collision detection to the fireball like this: 1. Open res://projectiles/fireball/fireball.tscn 2. Select Scene > Fireball 3. Go to Node next to the Inspector tab 4. Double click Signals > Area2D > area_entered(...) 5. And connect it to the existing Fireball method _on_body_entered NOTE! that this is the first time I'm not saying \"pick the defaults in the dialog\" So first use pick : And then choose the _on_body_entered method: Adapt func _on_body_entered like so: @ export var damage = 1 func _on_body_entered ( body ): # if the body _can_ take damage, give it _my_damage if body . has_method ( \"take_damage\" ): body . take_damage ( damage ) # ... leave the rest ... So the var named body can be a slime and a slime will have the method take_damage . If it does, we invoke it! If not, it's not 'damageable' . Programmer's rant We call this duck-typing: \"If it looks like a duck and quacks like a duck...\" : if the target has a quack() method, we assume proactively it's a duck. In typed languages you need to declare an interface which tells the compiler (or interpreter) what methods the class implements. For a loosely typed scripting language like gdscript duck-typing makes more sense -- although inevitably you run into the request for type hints, like python did... anyway... whatever... you just want to make cool games, right? ...and if they crash, just ask a programmer! /Programmer's rant Test with F5 ! All sorts of stuff is not working as expected! Fireballs just mysteriously start dissipating Slimes are still not collided with by fireballs! So let's tackle both issues in reverse order :) Issue #2: Slimes are not in the correct collission layer/mask We forgot the collision layer and collision mask: Open res://monsters/slime/slime.tscn Go to Inspector > Collision Add the number 2 to the collision mask and -layer: That should fix it. The fireball should now dissipate upon hitting the slime and the slime should report its damage to the log: Fireballs collide into eachother now .. and dissipate So that mystery was solved quite quickly. Let's make sure that fireballs do not beat eachother anymore by deselecting collision layer 2 : Open res://projectiles/fireball/fireball.tscn Go to Inspector > Collision Deselect Layer > 2 : That should fix it: Allow the slime to die from damage The next step is not to allow that strange bit of negative hp ! All it takes is doing stuff we already did with the fireball: autoloaded texture renditions Open res://texture_renditions.gd Add the properties slime and slime_dissipate var slime = preload ( \"res://monsters/slime/green/5.png\" ) . get_image () var slime_dissipate : Array = [] And use get_dissipate_renditions to generate renditions for slime-death func _ready (): slime_dissipate = get_dissipate_renditions ( slime , 10 , 2 , 0.9 ) fireball_dissipate = get_dissipate_renditions ( fireball , 15 , 1 , 0.5 ) Add a MovementState and animation for slime death Next open the slime script to add the renditions. Open res://projectiles/fireball/fireball.gd Copy the rendition load code to your paste-buffer ( Ctrl + C ) # The sprite_frames of $AnimatedSprite2D is a singleton, so after calling # add_animation one time, it exists for all other instances if \"dissipate\" not in $ AnimatedSprite2D . sprite_frames . get_animation_names (): # Add a new animation to the SpriteFrames instance of the $AnimatedSprite2D node $ AnimatedSprite2D . sprite_frames . add_animation ( \"dissipate\" ) # Loop through all rendition images in the global singleton fireball_dissipate for rendition in TextureRenditions . fireball_dissipate : # Add them as a frame to $ AnimatedSprite2D . sprite_frames . add_frame ( \"dissipate\" , rendition ) Now open res://monsters/slime/slime.gd And paste the copied code into the _ready() function, adjusting one bit: .fireball_dissipate becomes .slime_dissipate if \"dissipate\" not in $ AnimatedSprite2D . sprite_frames . get_animation_names (): # Add a new animation to the SpriteFrames instance of the $AnimatedSprite2D node $ AnimatedSprite2D . sprite_frames . add_animation ( \"dissipate\" ) # Loop through all rendition images in the global singleton for rendition in TextureRenditions . slime_dissipate : # Add them as a frame to $ AnimatedSprite2D . sprite_frames . add_frame ( \"dissipate\" , rendition ) When the slime's hp is <= 0 then it should die Add the MovementState.DYING to the enum: enum MovementState { AIRBORNE , FLOOR_BOUNCE , DYING } So when the slime takes damage and drops below zero, set it: func take_damage ( dmg : int ): hp -= dmg if hp <= 0 : movement_state = MovementState . DYING Make sure it is not reset in set_movement_state() and disable collisions: func set_movement_state (): if movement_state == MovementState . DYING : # FIXME: move to pick_collision_shape_for_movement_state $ AirborneCollisionShape . disabled = true $ FloorBounceCollisionShape . disabled = true elif is_on_floor (): if movement_state == MovementState . AIRBORNE : velocity . x = 0 $ FloorBounceTimer . start () movement_state = MovementState . FLOOR_BOUNCE else : movement_state = MovementState . AIRBORNE And handle it in the movement_state handler: func handle_movement_state (): if movement_state == MovementState . DYING : velocity = Vector2 ( 0 , 0 ) # the rest was there already (behind 'el') elif is_on_wall (): follow_player () pick_collision_shape_for_movement_state () pick_sprite_for_movement_state () And make sure the correct animation for dying is picked: func pick_sprite_for_movement_state (): match ( movement_state ): MovementState . FLOOR_BOUNCE : $ AnimatedSprite2D . animation = \"floor_bounce\" MovementState . AIRBORNE : $ AnimatedSprite2D . animation = \"airborne\" MovementState . DYING : $ AnimatedSprite2D . animation = \"dissipate\" The dissipate timer Now let's add a DissipateTimer to the Slime scene Open res://monsters/slime/slime.tscn Go to Scene > Slime and add a child node Timer And rename it to DissipateTimer Make sure it is set to One Shot under Inspector , leave Wait Time to 1s Connect its timeout() -signal to slime.gd in the usual way (defaults in dialog and such) Implement as follows: func _on_dissipate_timer_timeout (): queue_free () And of course let's not forget to fire the timer when the slime has no hp left: func take_damage ( dmg : int ): hp -= dmg if hp <= 0 : movement_state = MovementState . DYING $ DissipateTimer . start () Test again and make sure the slime does stay dead... Make the slime hurt the player by bouncing into the player Being a CharacterBody2D , same as the Player is, the Slime does not have the body_entered , nor does it have area_entered out of the box. It is probably easier to just code collisions with the player more traditionally: in its movement handler using its get_slide_collision_* methods like documented in Detecting collisions : Open slime.gd Add a default damage as public property: @ export var damage = 1 Write a function damage_player : func damage_player (): # detect collisions based on collision count for i in get_slide_collision_count (): # get current colliding other thing var collider = get_slide_collision ( i ) . get_collider () # test if other thing is the Player # (collider could be null, so test existence first) if collider and collider . name == \"Player\" : # make the player take damage collider . take_damage ( damage ) Testing with F5 we soon run into an issue: the player does not yet have the take_damage method. Open player.gd Write the method take_damage : func take_damage ( damage : float ): print ( \"Ouch! I took: \" + str ( damage ) + \" damage!\" ) Test with F5 again and notice: she's taking a lot of damage: Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! So let's leave our player immortal for a while longer, because tweaking how fast she should die is pretty hard. We want to move on to bigger and better things for now. Just take a pass on her take_damage function for now so we don't clog up the log: func take_damage ( _damage ): # leave Zelia immortal for a while longer pass Just one more tweak: bounce off of the player One thing we should do now to finish the Slime behaviour is to allow it to bounce off of the player a little with the extra benefit that it won't collide into her that often. We can reuse its start_jump method for that: # test if other thing is the Player if collider . name == \"Player\" : # make the player take damage collider . take_damage ( damage ) # this is new start_jump () Testing again shows one more error: the slime double jumps! You can fix it by killing the FlourBounceTimer when a jump is started: func start_jump (): $ FloorBounceTimer . stop () velocity . y = JUMP_VELOCITY follow_player () That's a little much, maybe the slime should bounce off a bit less high: func start_jump ( init_velocity = JUMP_VELOCITY ): $ FloorBounceTimer . stop () velocity . y = init_velocity follow_player () Now in damage_player we can invoke it with a different init_velocity like: start_jump(-150) , still taking JUMP_VELOCITY as its default value. Add the tree-trunk terrain Because Zelia (in the original game) runs into tiles that are not just squares, our rewrite must have them as well. Open res://world.tscn . Create a new Terrain in World > Inspector > Terrain Sets > Terrains : \"Tree Trunk\" Add the res://surface_maps/tree-trunk/1.png to our existing TileSet - like we learned on day 2 . Be sure to assign Terrain 1 this time, under the Select step When you get to the step for Physics with the F -hotkey we're going to do something new, but first... Don't forget to also create the 1 alternative tile (in case you want to handle all the drag-and-draw painting) Create polygons So textures in these tiles are not square at all! It would look pretty silly for Zelia to bump into free air. You can easily fix this by manipulating the physics -rect to become a polygon. Under Select > Physics > Physics Layer 0 there is an image with that rect drawn over it. Just click on the edges to add a new draggable vertex and manipulate that rect until it looks right: Next finish up the rest of the tree-trunk tiles until it looks like this: Don't forget to draw the the Terrains Peering Bit for each tile using the Tree Trunk terrain from Terrain Set 0 So that bit should look like this: Draw and test! Can Zelia now run up a slope? Why not try it out yourself.. Anyway, the place to test it out is in res://world.tscn and drawing this new terrain into the scene like we learned on day 2 : Solve Technical debt 3 Now we want to achieve these next steps: 1. breakable tiles 2. tiles that fall down 3. tiles we can use as background scenery However, currently we only have one scene containing our TileMap and that scene is the TileMap . Which we renamed to World . That is a tight coupling between a TileMap and the entire rest of the game we foresaw technical debt on day 2 . What we need is that the main scene of our game has instances of our TileMap -scene: Create a new scene called Game that extends Node Save it into res://game.tscn Rename res://world.tscn to res://terrains.tscn Rename the scene name World to Terrains Delete all Terrains ' child nodes ( Player , Fireball - if still present, Slime s) Detach the world.gd -script by right clicking on the Terrains -node: Rename res://world.gd to res://game.gd Now open the game.tscn again and attach the game.gd script to it Make sure the script now extends Node in stead of TileMap : extends Node func _on_player_cast_projectile ( spell_class , direction , origin ): var spell = spell_class . instantiate () add_child ( spell ) spell . rotation = direction spell . position = origin spell . velocity = Vector2 . from_angle ( direction ) * 150.0 Attach the following scenes as children for Game by dragging them from the FileSystem tab: res://terrains.tscn res://player/player.tscn res://monsters/slime/slime.tscn Make res://game.tscn the main scene by right clicking it in the FileSystem tab Check the scene, which in my case looked like this: There is one thing: Zelia can't shoot anymore. Fix the fireballs So we need to connect the cast_projectile -signal again to _on_player_cast_projectile (moved to game.gd ), like we did on day 4 : Select the Player -node (the child node of Game ) Go to Node > Signals Double click cast_projectile Select pick Double click on _on_player_cast_projectile(...) Click connect Test the game with F5 Make tiles Zelia can break This next bit took quite some research and avenues attempted yet not taken. It might seem like the steps are evident and told as if they're easy (or even might have been done much better). They are, however, like many things, the result of effort, trial and error. That's why you just get the steps without the philosophies. The final approach in very simplified terms Say a Terrains -instance is breakable using Metadata When the Terrains -instance is _ready() check if this breakable -field is true . If yes, loop through all the tiles in this instance For each tile, signal an event add_breakable_tile Let the game.gd script handle this signal .. .. by creating instances of a new scene called BreakableTile After the loop is done, invoke queue_free() to clear this Terrains -instance But first: preparations! Erase the tiles in the Terrains -scene First let's erase the tiles in the Terrains -scene. Open res://terrains.tscn . Click the Scene > Terrains -node Select TileMap in the bottom pane Select the Terrains -tab Pick on of the Terrains Select the eraser to erase the tiles Open res://game.tscn Now click the child node Terrains Navigate to TileMap > Terrains in the bottom pane again And draw some terrain in the Terrains - instance of the Game -scene Adding a new Terrain -instance to Game Now, without too many philosophies (as promised), thus further ado: Drag another instance of res://terrains.tscn into the Game scene It will be called Terrains2 if you did that right Rename it to BreakableTerrains Draw one tile while BreakableTerrains is active. Test if it is indeed in a the separate node by toggling its visibility: Adding Metadata fields Now that we have a new instance of terrain in the game, we need to transmogrify it into breakable terrain. That means telling our code we intend to do that using metadata . Open res://terrains.tscn Navigate to the Inspector Scroll all the way down to find the + Add Metadata -button Click that button In the dialog give it the name breakable Keep the type as bool Click Add : Don't forget to save! Open res://game.tscn Click on BreakableTerrains Pop open the Inspector > Metadata And here check On the Breakable field: Also notice the revert arrow, which implies we overrode default behaviour Attach a new terrains.gd script Open res://terrains.tscn Click the -button Leave defaults active and click Create First let's check if our new Metadata -field works: extends TileMap func _ready (): if get_meta ( \"breakable\" ): print ( name + \" is breakable\" ) Test with F5 and observe: BreakableTerrains is breakable A thorough guide to the poor man's debugger Now we will loop through the tiles and read all the properties we'll need to signal the game to create that BreakableTile -instance we announced before . All the godot methods and properties used are linked to their respective class-references: Loop through the tiles in our current (only) layer using get_used_cells func _ready (): if get_meta ( \"breakable\" ): print ( name + \" is breakable\" ) # Loop through the tile positions in our current (only) layer for cell in get_used_cells ( 0 ): print ( cell ) print ( cell * tile_set . tile_size ) Observe the log: BreakableTerrains is breakable (7, 2) (105, 30) The (7, 2) is the string serialization of a Vector2i , which represents the position of this tile on the TileMap 's grid. Our tile_set . tile_size is 15x15 so the position of the BreakableTile will become (105, 30) plus the position of this TileMap instance. Let's just print that TileMap -instance's position just to check: extends TileMap func _ready (): if get_meta ( \"breakable\" ): print ( name + \" is breakable\" ) print ( name + \"'s origin is: \" + str ( position )) # Loop through the tile positions in our current (only) layer for cell in get_used_cells ( 0 ): print ( \"Tile grid position: \" + str ( cell )) print ( \"BreakableTile target position: \" + str ( Vector2i ( position ) + cell * tile_set . tile_size )) Run with F5 and inspect the log: BreakableTerrains is breakable BreakableTerrains's origin is: (0, 0) Tile grid position: (7, 2) BreakableTile target position: (105, 30) Open res://game.tscn and select BreakableTerrains Change its position in Inspector > Transform > Position Rerun the game and inspect the log again: BreakableTile target position: (115, 41) Changed the BreakableTerrains ' position by +(10,11) as can be observed in the log Quickly revert the position to (0, 0) , which makes reasoning easier. Next use get_cell_source_id and tile_set . get_source to obtain the TileSetAtlasSource we used for our textures and physics polygons: for cell in get_used_cells ( 0 ): print ( \"Tile grid position: \" + str ( cell )) print ( \"BreakableTile target position: \" + str ( Vector2i ( position ) + cell * tile_set . tile_size )) var source_id = get_cell_source_id ( 0 , cell ) var tileset_source : TileSetAtlasSource = tile_set . get_source ( source_id ) print ( \"TileSetAtlasSource: \" + tileset_source . resource_name ) Test with F5 again: BreakableTerrains is breakable BreakableTerrains's origin is: (0, 0) Tile grid position: (7, 2) BreakableTile target position: (105, 30) TileSetAtlasSource: grass-and-dirt Next use our cell to obtain the position in the atlas texture of the current tile using get_cell_atlas_coords var tile_atlas_coords = get_cell_atlas_coords ( 0 , cell ) print ( \"tile_atlas_coords: \" + str ( tile_atlas_coords )) And of course, this also should be multiplied by our tile_set . tile_size to get the pixel position on the underlying texture. print ( \"tile_atlas_coords: \" + str ( tile_atlas_coords * tile_set . tile_size )) In order to clip out the correct image we need the Texture2D -resource of the atlas as well print ( \"texture: \" + tileset_source . texture . resource_path ) Just to be sure we're still on the same page, check your debug log again: BreakableTerrains is breakable BreakableTerrains's origin is: (0, 0) Tile grid position: (7, 2) BreakableTile target position: (105, 30) TileSetAtlasSource: grass-and-dirt tile_atlas_coords: (60, 15) texture: res://surface_maps/grass-and-dirt/1.png The last bit of information up next was the one that took me the longest: the collision polygons of this tile ( especially because I forgot to draw the polygon for the tile I was testing :D ). Also, the obstinate use of obtain umpten times is intentional : it's an achievement . Use the tile_atlas_coords we obtained with the tileset_source we obtained to obtain the tile_data of this tile with get_tile_data And then invoke get_collision_polygon_points to obtain the ... wait for it ... PackedVector2Array representing the collision polygon of this tile: var tile_data = tileset_source . get_tile_data ( tile_atlas_coords , 0 ) print ( \"polygon: \" + str ( tile_data . get_collision_polygon_points ( 0 , 0 ))) And that should look like this in your debug log: polygon: [(-7.5, -7.5), (7.5, -7.5), (7.5, 7.5), (-7.5, 7.5)] Now, just to make sure we did everything correctly ( did you also notice the 5 magic zeroes 0 we introduced, representing layers and layers and more layers of which we only seem to have one at each turn? ).. Let plant a tree with a divergent polygon as well (in our BreakableTerrains -instance of course): That should log something similar to this: Tile grid position: (9, 3) BreakableTile target position: (135, 45) TileSetAtlasSource: tree-trunk tile_atlas_coords: (75, 0) texture: res://surface_maps/tree-trunk/1.png polygon: [(-7.5, -7.5), (-6.125, -7.5), (-3.25, 0.125), (0.5, 4.5), (5.625, 5.75), (7.5, 7.5), (-7.5, 7.5)] Declaring and emitting the add_breakable_tile signal Now that we've collected all the information we need for the game to spawn in one BreakableTile per tile in our BreakableTerrains -instance we're ready to us it. Declare the signal add_breakable_tile as follows in terrains.gd : signal add_breakable_tile ( position : Vector2i , texture : Texture2D , texture_pos : Vector2i , # collisigon is my personal shorthand for \"collision polygon\" collisigon : PackedVector2Array ) And emit it in the loop ( note we remove all the print s ): func _ready (): if get_meta ( \"breakable\" ): # Loop through the tile positions in our current (only) layer for cell in get_used_cells ( 0 ): var source_id = get_cell_source_id ( 0 , cell ) var tileset_source : TileSetAtlasSource = tile_set . get_source ( source_id ) var tile_atlas_coords = get_cell_atlas_coords ( 0 , cell ) var tile_data = tileset_source . get_tile_data ( tile_atlas_coords , 0 ) emit_signal ( \"add_breakable_tile\" , Vector2i ( position ) + cell * tile_set . tile_size , tileset_source . texture , tile_atlas_coords * tile_set . tile_size , tile_data . get_collision_polygon_points ( 0 , 0 ) ) Now in res://game.tscn select BreakableTerrains again Navigate to Node > Signals Double click add_breakable_tile Leave the defaults (so target is game.gd ) and click Connect Now print the inputs in this new listener: func _on_breakable_terrains_add_breakable_tile ( target_pos : Vector2 , texture : Texture2D , texture_pos : Vector2i , collisigon : PackedVector2Array ): print ( \"Target position of BreakableTile: \" + str ( target_pos )) print ( \"Atlas texture resource dir: \" + str ( texture . resource_path )) print ( \"Position of this tile in the atlas: \" + str ( texture_pos )) print ( \"Collision polygon of this tile: \" + str ( collisigon )) Go back to res://terrains.gd Earlier we announced in step 7 we would call queue_free after all the tiles in the map were signalled : func _ready (): if get_meta ( \"breakable\" ): # Loop through the tile positions in our current (only) layer # ... leave the for-loop in tact of course ... # Remove this TileMap from the parent scene queue_free () If you test again now, all we have left is the print messages in our console, but the (as yet) unbreakable tiles from the BreakableTerrains - TileMap are gone. Creating the BreakableTile scene Now in order the game.gd to instantiate breakable tiles and attach then as children we first need to make a BreakableTile -scene. It will be a bit of a weird scene, because we will be giving it empty child-nodes: - An empty Sprite2D .. - .. and an empty CollisionPolygon2D Create a new scene of type StaticBody2D In the scene tree rename its root node to BreakableTile Save the scene as res://tiles/breakable_tile.tscn Give it one child node of type Sprite2D And another child node of type CollisionPolygon2D It doesn't look like much in the - scene view, maybe temporarily we should add a texture for testing purposes: Create 15x15 pixel sized .png of any type you prefer (as long as it is visible !) Save that file into res://tiles/placeholder.png Select the BreakableTile > Sprite2D node Go to Inspector and select Texture > new ImageTexture Drag the placeholder.png into the select-box Now we can instantiate the scene with at the right position in the game.gd script: Open res://game.gd Use preload to import the BreakableTile -scene: var BreakableTile = preload ( \"res://tiles/breakable_tile.tscn\" ) Instatiate it in _on_breakable_terrains_add_breakable_tile And then use the position argument to set its position property func _on_breakable_terrains_add_breakable_tile ( target_pos : Vector2 , texture : Texture2D , texture_pos : Vector2i , collisigon : PackedVector2Array ): var new_tile : StaticBody2D = BreakableTile . instantiate () new_tile . position = target_pos This still does nothing visible. We need to add the BreakableTile -instance(s) to the game tree, which would make us see our rest://tiles/placholder.png -texture. HEADS UP! This next snippet won't work: func _on_breakable_terrains_add_breakable_tile ( target_pos : Vector2 , texture : Texture2D , texture_pos : Vector2i , collisigon : PackedVector2Array ): var new_tile : StaticBody2D = BreakableTile . instantiate () new_tile . position = target_pos # this is the code we want to execute add_child ( new_tile ) For the sake of learning, press F5 . So now we get this error in our console: game.gd:16 @ _on_breakable_terrains_add_breakable_tile(): Parent node is busy setting up children, `add_child()` failed. Consider using `add_child.call_deferred(child)` instead. That sounds super helpful! Let's try it out! func _on_breakable_terrains_add_breakable_tile ( target_pos : Vector2 , texture : Texture2D , texture_pos : Vector2i , collisigon : PackedVector2Array ): var new_tile : StaticBody2D = BreakableTile . instantiate () new_tile . position = target_pos add_child . call_deferred ( new_tile ) Test again with F5 and voil\u00e0, our pretty placeholder is added tot the scene: But wait, what's wrong with this picture? Exactly, the placement of our breakable tiles looks wrong, even though we correctly calculated their position. We need to fix the position of our Sprite2D and CollisionPolygon2D to match where the tile will be placed: Open res://tiles/breakable_tile.tscn in -scene view Select BreakableTile > Sprite2D Then set Inspector > Transform > Position to x=7.5 and y=7.5 Select BreakableTile > CollisionPolygon2D Also set Inspector > Transform > Position to x=7.5 and y=7.5 It should now look like this: Lesson learned : I'm not liking these 7.5 's I'm starting to see everywhere... I should have gone for 16x16 last year when I started drawing stuff based on my easy maths. Setting the texture and collision polygon of the BreakableTile The rest of the properties we prepared in game.gd we will pass on to properties for the BreakableTile itself to handle in its _ready -function. Open res://tiles/breakable_tile.tscn Select the root node BreakableTile Click the -button Leave the defaults and save into res://tiles/breakable_tile.gd Add these public properties: extends StaticBody2D @ export var texture : Texture2D @ export var texture_pos : Vector2i @ export var collisigon : PackedVector2Array func _ready (): print ( \"BreakableTile.position: \" + str ( position )) print ( \"BreakableTile.texture: \" + str ( texture . resource_path )) print ( \"BreakableTile.texture_pos: \" + str ( texture_pos )) print ( \"BreakableTile.collisigon: \" + str ( collisigon )) Open res://game.gd Set these new public properties in our signal listener: func _on_breakable_terrains_add_breakable_tile ( target_pos : Vector2 , texture : Texture2D , texture_pos : Vector2i , collisigon : PackedVector2Array ): var new_tile = BreakableTile . instantiate () new_tile . position = target_pos new_tile . texture = texture new_tile . texture_pos = texture_pos new_tile . collisigon = collisigon add_child . call_deferred ( new_tile ) Test this code again with F5 and confirm we're still seeing the same thing in our consoles: BreakableTile.position: (105, 30) BreakableTile.texture: res://surface_maps/grass-and-dirt/1.png BreakableTile.texture_pos: (60, 15) BreakableTile.collisigon: [(-7.5, -7.5), (7.5, -7.5), (7.5, 7.5), (-7.5, 7.5)] BreakableTile.position: (135, 45) BreakableTile.texture: res://surface_maps/tree-trunk/1.png BreakableTile.texture_pos: (75, 0) BreakableTile.collisigon: [(-7.5, -7.5), (-6.125, -7.5), (-3.25, 0.125), (0.5, 4.5), (5.625, 5.75), (7.5, 7.5), (-7.5, 7.5)] Now let's set the correct texture, texture position and polygon in code: func _ready (): $ Sprite2D . set_texture ( texture ) $ Sprite2D . region_rect = Rect2 ( texture_pos . x , texture_pos . y , 15 , 15 ) $ CollisionPolygon2D . polygon = collisigon Testing with F5 you'll probably get this, like me (the entire atlas as a texture): That is because you need to enable the region_rect feature we used. You can either do this in code or in the BreakableTile -inspector. 1. in code: $Sprite2D.region_enabled = true 2. in the scene select the Sprite2D -child node: check Inspector > Region > Enabled to On It's really up to you which you choose, but this tutorial has used the configuration over code approach so far, which implies the 2nd choice... (Usually, as a programmer, I prefer code as configuration, keeping everything nice and together, in stead of in separate places). Fix the collision layer and -mask One last thing you'll have noticed by now is that the collision layer and -mask are not the same for our BreakableTile as for our Terrains scene. That explains fireballs flying right through them. Let's make them match. Open res://tiles/breakable_tile.tscn Go to Inspector > Collision For Layer check both 1 and 2 And for Mask check both 1 and 2 as well Make them break!! Finally ! Up till now we only made a copy of some tiles as a StaticBody2D , which made them behave the same as the TileMap . However, now we can use fireball-collisions to reduce some HP -property and let the tiles disappear when they're out of HP . Here we will use a 2-step approach: 1. Give the breakable tiles an HP property, reduce it on 'take_damage', make them queue_free 2. Generate 'cracked' renditions of the terrain textures to show the user the damage Remove tiles that are broken We made things that can take damage implement the take_damage -function. That way, things that give damage have a place to invoke that damage. Like our fireballs. Let's see if we can achieve that effect right now 1. Open res://tiles/breakable_tile.gd 2. Implement take_damage() like this: func take_damage ( dmg : float ): print ( \"Breakable tile taking \" + str ( dmg ) + \" damage\" ) Then press F5 and shoot some fireballs at it. Check the console if we're still seeing the same things: Breakable tile taking 1 damage Breakable tile taking 1 damage Breakable tile taking 1 damage Yup! That works. Now let's add a public property called hp which we can set from metadata later. Add the hp property on top of breakable_tile.gd and set it to 10 as a default. extends StaticBody2D @ export var hp : float = 10.0 @ export var texture : Texture2D @ export var texture_pos : Vector2i @ export var collisigon : PackedVector2Array Implement take_damage like this now: func take_damage ( dmg : float ): hp -= dmg if hp <= 0 : queue_free () Then press F5 and shoot some fireballs at it again . Watch with satisfaction as these tiles disappear after only 10 hits with a fireball: HP as metadata As a level editor you want control over the amount HP a breakable tile gets. We can achieve this by adding another metadata field to our Terrains - Tilemap scene called.. Hp . Let's do that now: Open res://terrains.tscn and select the Terrains root node Go to Inspector > Metadata > + Add Metadata Set the Name to hp and the type to float or int (your quacking choice) Click Add Set the value to 10 to serve as the default value Now open res://terrains.gd Add hp as a 5th parameter to add_breakable_tile signal add_breakable_tile ( position : Vector2i , texture : Texture2D , texture_pos : Vector2i , collisigon : PackedVector2Array , hp : float ) Add the hp -metadata to the emit_signal -call for each tile: emit_signal ( \"add_breakable_tile\" , Vector2i ( position ) + cell * tile_set . tile_size , tileset_source . texture , tile_atlas_coords * tile_set . tile_size , tile_data . get_collision_polygon_points ( 0 , 0 ), get_meta ( \"hp\" ) ) Open res://game.gd Add the hp to _on_breakable_terrains_add_breakable_tile and set it on the BreakableTile instance there: func _on_breakable_terrains_add_breakable_tile ( target_pos : Vector2 , texture : Texture2D , texture_pos : Vector2i , collisigon : PackedVector2Array , hp : float ): var new_tile = BreakableTile . instantiate () new_tile . position = target_pos new_tile . texture = texture new_tile . texture_pos = texture_pos new_tile . collisigon = collisigon new_tile . hp = hp add_child . call_deferred ( new_tile ) To test, see how it works when you change hp metadata in the BreakableTerrains tilemap of your game. Generate some pretty cracks to show the tile damage What is missing is some visual feedback of tiles breaking. For that effect, we will revisit our approach to renditions , like we did with the dissipating fireballs . This time we will use a set of .png files as an alpha mask. You can download them from here: Download cracked-renditions.zip Extract cracked-renditions.zip in res://surface_maps Open res://texture_rendition.gd Preload the files as an image resource like this: var crack_mask_0 = preload ( \"res://surface_maps/crack-mask-0.png\" ) . get_image () var crack_mask_1 = preload ( \"res://surface_maps/crack-mask-1.png\" ) . get_image () var crack_mask_2 = preload ( \"res://surface_maps/crack-mask-2.png\" ) . get_image () var crack_mask_3 = preload ( \"res://surface_maps/crack-mask-3.png\" ) . get_image () And prepare these 2 data objects to be used in our rendition code: var crack_masks = [ crack_mask_0 , crack_mask_1 , crack_mask_2 , crack_mask_3 ] var cracked_rendition_map : Dictionary = {} The first function we'll write is a reusable function get_alpha_mask_rendition , which takes 2 arguments src_image : Image , the image we want to make partly transparent using an alpha mask alpha_map : Image , the image we will use to 'draw transparency' on the source image, as it were func get_alpha_mask_rendition ( src_image : Image , alpha_map : Image ): # create a destination image with the same properties as the source image var dst_rendition = Image . create ( src_image . get_width (), src_image . get_height (), false , src_image . get_format ()) # loop through all the pixels in the source image for x in range ( src_image . get_width ()): for y in range ( src_image . get_height ()): # Get the original color var src_color = src_image . get_pixel ( x , y ) # Get the color representing the amount of transparency to draw var alpha_color = alpha_map . get_pixel ( x , y ) # Calculate how much transparency this should be, by inverting # the alpha-amount of the mask's color var dest_alpha = 1.0 - alpha_color . a if 1.0 - alpha_color . a > 0.0 else 0.0 # draw a pixel to the destination image based on the source pixel # and set the alpha to the lowest of these 2 alpha values: # 1. dest_alpha # 2. the alpha of the source pixel dst_rendition . set_pixel ( x , y , Color ( src_color . r , src_color . g , src_color . b , min ( src_color . a , dest_alpha ))) # return the destination image as an ImageTexture object return ImageTexture . create_from_image ( dst_rendition ) Let's then write a function get_cracked_renditions which takes 2 arguments source_id : int , a key for our dictionary to make sure the rendition is generated only once in code (singleton pattern) src_image : Image the image we want to generate cracked renditions for func get_cracked_renditions ( source_id : int , src_image : Image ): if source_id in cracked_rendition_map : return cracked_rendition_map [ source_id ] print ( \"Assert single invocation for get_cracked_renditions:\" + str ( source_id )) # copy the source image into the rendition map cracked_rendition_map [ source_id ] = [ ImageTexture . create_from_image ( src_image )] # for each alpha mask we preloaded into the crack_masks array ... for crack_mask in crack_masks : # ... make a rendition with get_alpha_mask_rendition and add it to # the dictionary using source_id as key cracked_rendition_map [ source_id ] . append ( get_alpha_mask_rendition ( src_image , crack_mask )) # of course return the dictionary return cracked_rendition_map [ source_id ] Allow those breakable tiles to fall down Rigid -> Static -> Rigid -> Character -> Area -> Static -> Rigid -> ooooh... Spoiler: it was StaticBody2D I wanted all along. Technical debt 6 While following the my first 3D game tutorial I was reminded of Godot's group tagging feature in part 06. on squashing monsters : Group tagging in Godot Both our BreakableTile s and our Slimes should be tagged as part of some group in order for us to better determine what to do when a collision takes place with them. Reuse tiles as background scenery The original Zelia game used a simple trick for background textures: add a little transparency to the terrain maps and draw them behind the rest of the game. Although we could probably do this without any complexity, let's use this oppurtunity to explore 2D fragment shaders.","title":"Day 5 - Slimes, Breaking tiles, Falling Tiles, Scenery Tiles and Shaders"},{"location":"day-5/#day-5-slimes-breaking-tiles-falling-tiles-scenery-tiles-and-shaders","text":"A long title for a long episode!","title":"Day 5 - Slimes, Breaking tiles, Falling Tiles, Scenery Tiles and Shaders"},{"location":"day-5/#what-well-do-today","text":"Make a bouncing Slime monster Add the tree-trunk terrain Make tiles Zelia can break Allow those breakable tiles to fall down Technical Debt 6 Reuse tiles as background scenery","title":"What we'll do today"},{"location":"day-5/#make-a-bouncing-slime-monster","text":"Every game needs one.","title":"Make a bouncing Slime monster"},{"location":"day-5/#setting-up-the-slime-scene","text":"Download the zip: assets/green-slime.zip Create the resource dirs res://monsters/slime/green Extract the .png files in that res://monsters/slime/green dir Create a new CharacterBody2D -scene Rename it to Slime And save it into res://monsters/slime/slime.tscn Give slime a child node AnimatedSprite2D Navigate to its Inspector Sprite Frames > SpriteFrame > Animations Change default into airborne , add slime/green/5.png to it Add floor_bounce and add 1.png - 4.png to that -> in that order Set floor_bounce to 7 fps for the nicest effect:","title":"Setting up the slime scene"},{"location":"day-5/#add-2-collision-shapes","text":"Because our slime looks a little different depending on what state it's in, let's give it 2 collision shapes: Add a child CollisionShape2D -node to Scene > Slime Name it: AirborneCollisionShape Pick CircleShape2D under Inspector > Shape Align it nicely around the airborne animation sprite: Next: 1. Add another child CollisionShape2D -node to Scene > Slime 2. Name it: FloorBounceCollisionShape 3. Pick CapsuleShape2D under Inspector > Shape 4. Align it around the first floor_bounce animation sprite:","title":"Add 2 collision shapes"},{"location":"day-5/#setting-up-the-slimegd-script","text":"Add the slime to the main scene: Open res://world.tscn Drag at least one slime scene res://monsters/slimes/slime.tscn into the World -scene Test the main scene World with F5 and observe that the slime hangs there doing nothing: Open the res://monsters/slimes/slime.tscn scene Attach a script to it, picking the default values in the dialog You might notice a lot of suggested code for a CharacterBody2D - although it could be fun to try it out, it's not what we're looking for. Remove all code and replace the _physics_process function body with pass : extends CharacterBody2D func _physics_process ( delta ): pass","title":"Setting up the slime.gd script"},{"location":"day-5/#adding-the-movementstates","text":"We have 2 animations currently, so let's create 2 movement states to match: extends CharacterBody2D enum MovementState { AIRBORNE , FLOOR_BOUNCE } var movement_state : int func _ready (): # assume it starts out hanging in the air movement_state = MovementState . AIRBORNE # start up the correct animated sprite sprite frames for that state $ AnimatedSprite2D . animation = \"airborne\" $ AnimatedSprite2D . play () We also know the slime must bounce around. We can use some familiar stuff for that: # We want the level designer to be able to modify stuff like this. @ export var JUMP_VELOCITY = - 400.0 var gravity = ProjectSettings . get_setting ( \"physics/2d/default_gravity\" ) Now let's at the very least allow some move_and_slide() in the _physics_process , applying the gravity: func _physics_process ( delta ): velocity . y += gravity * delta move_and_slide () Now test again ith F5 - the slime falls down and lands on the tiles.","title":"Adding the MovementStates"},{"location":"day-5/#picking-the-right-collision-shape","text":"As we saw when we were setting up the scene, the slime has 2 CollisionShapes2D s attached of which only one should be active at a time, base on its movement_state . Create a func pick_collision_shape_for_movement_state : # enable the collision shape that matches the current movement state func pick_collision_shape_for_movement_state (): match ( movement_state ): MovementState . AIRBORNE : $ AirborneCollisionShape . disabled = false $ FloorBounceCollisionShape . disabled = true MovementState . FLOOR_BOUNCE : $ AirborneCollisionShape . disabled = true $ FloorBounceCollisionShape . disabled = false And make sure to invoke it once the slime is instantiated: func _ready (): # assume it starts out hanging in the air movement_state = MovementState . AIRBORNE # enable the collision shape that matches the movement state pick_collision_shape_for_movement_state ()","title":"Picking the right collision shape"},{"location":"day-5/#setting-the-right-movement-state-in-the-_physics_process","text":"When we programmed the player (hacked it together the 1st time) we had to do a lot of refactor work early on to make the player.gd code more understandable and maintainable. The most important step we took was to separate out two stages in the _physics_process to determine what the player should do in this iteration (this time around in the infinite loop): 1. set_movement_state() 2. handle_movement_state() Even though it felt artificial to force such a hard separation in 2 functions, it made some code that is easier for a human (like us, I hope) to reason about. Let's reapply it here, so first create the 2 new empty functions set_movement_state and handle_movement_state and invoke them from _physics_process , right after the gravity is applied: func _physics_process ( delta ): # Apply gravity velocity . y += gravity * delta # Set, and handle movement state set_movement_state () handle_movement_state () move_and_slide ()","title":"Setting the right movement state in the _physics_process"},{"location":"day-5/#programming-the-full-slime-behaviour-in-steps","text":"Now we will reason our way to a working, bouncing slime. Coding it in small steps: Make the slime bounce up and down Make the slime bounce in the direction of the player Make the slime take damage from fireballs Allow the slime to die from damage Make the slime hurt the player by bouncing into the player","title":"Programming the full slime behaviour in steps"},{"location":"day-5/#make-the-slime-bounce-up-and-down","text":"Let's start out by making it land nicely. So we set the correct movement state and animated sprite when the slime is on the floor: func set_movement_state (): if is_on_floor (): movement_state = MovementState . FLOOR_BOUNCE pick_collision_shape_for_movement_state () $ AnimatedSprite2D . animation = \"floor_bounce\" Test using F5 . The next step is to make it bounce up again round about when the \"floor_bounce\" animation finishes. We'll need a one-shot timer for that and we need to start it at the right moment: Go to Scene > Slime and add a child node Timer Rename it to FloorBounceTimer Make sure One Shot is check to On under Inspector Set its Wait Time to 0.571s \"Why 0.571s ,\" you say? Well, it's 7fps times 4 animation frames: 1 / 7 * 4 . Go to Node > Timer and double-click timeout() Keep the defaults and attach it to the Slime 's script So this is the moment we want the slime to jump up again, let's write: func start_jump (): velocity . y = JUMP_VELOCITY func _on_floor_bounce_timer_timeout (): start_jump () We also need to start the timer when we know the slime has landed: func set_movement_state (): if is_on_floor (): # place this new code _before_ changing the movement_state! # so only start the timer at the moment of _landing_ if movement_state == MovementState . AIRBORNE : $ FloorBounceTimer . start () movement_state = MovementState . FLOOR_BOUNCE pick_collision_shape_for_movement_state () $ AnimatedSprite2D . animation = \"floor_bounce\" Test with F5 : it only flies up once and it looks off. We're still missing something! We need to set the correct movement state, animation and collision shape for when is_on_floor() is false : func set_movement_state (): if is_on_floor (): # ... leave the same ... else : movement_state = MovementState . AIRBORNE pick_collision_shape_for_movement_state () $ AnimatedSprite2D . animation = \"airborne\" Test with F5 : that looks a lot better","title":"Make the slime bounce up and down"},{"location":"day-5/#refactor-early","text":"The code is cluttering up already. Also, we have not made use of our somewhat artificial separation between set_movement_state and handle_movement_state yet. That separation was supposed to make the code easier to reason about, So now apply the following early ' incisions ' >:) Move the code that is more about handling the current movement_state to the function handle_movement_state : func handle_movement_state (): pick_collision_shape_for_movement_state () # pick the animation sprite for the current movement state match ( movement_state ): MovementState . FLOOR_BOUNCE : $ AnimatedSprite2D . animation = \"floor_bounce\" MovementState . AIRBORNE : $ AnimatedSprite2D . animation = \"airborne\" Now you can remove a lot of code from set_movement_state , leaving only the stuff that is more about setting a new movement_state : func set_movement_state (): if is_on_floor (): if movement_state == MovementState . AIRBORNE : $ FloorBounceTimer . start () movement_state = MovementState . FLOOR_BOUNCE else : movement_state = MovementState . AIRBORNE We still have a match -block that needs a comment to explain what it does. Let's fix that by creating a function for it: func pick_sprite_for_movement_state (): match ( movement_state ): MovementState . FLOOR_BOUNCE : $ AnimatedSprite2D . animation = \"floor_bounce\" MovementState . AIRBORNE : $ AnimatedSprite2D . animation = \"airborne\" And invoke it from handle_movement_state like so: func handle_movement_state (): pick_collision_shape_for_movement_state () pick_sprite_for_movement_state () Did you notice we applied the lesson we learned on day 3 about refactoring big functions ?","title":"Refactor early."},{"location":"day-5/#make-the-slime-bounce-in-the-direction-of-the-player","text":"So, now that the slimes are bouncing up and down nicely, we need to make them aware of where their only enemy is: you , the player. So we already learned a surefire approach through using singletons (or Autoload ) on day 4 . Let's apply that again: Go to Project > Project Settings... > Autoload Fill in PlayerState under Node Name and click Add In the dialog keep the defaults and create the new file Open res://player_state.gd Add a var position of type Vector2 When _ready initialize it with Vector2.ZERO : extends Node var position : Vector2 func _ready (): position = Vector2 . ZERO","title":"Make the slime bounce in the direction of the player"},{"location":"day-5/#updating-playerstateposition","text":"Now this new PlayerState singleton must be updated at least every time the player moves. Do this by adding this one line to a suitable function in player.gd : func _process ( _delta ) PlayerState . position = position","title":"Updating PlayerState.position"},{"location":"day-5/#using-playerstateposition-in-slimegd","text":"Now the slime can't fly, so the only property we need to update in slime.gd is the x-position. The effect we want to achieve is that the slime only moves on the x-axis when airborne. That makes sense because slimes are sticky and do not slide around while stuck to the floor. So the moment that we want to decide its velocity.x is when its jump starts and the moment that we want to stop x movement is when it lands. Go script it: @ export var X_VELOCITY = 100 func start_jump (): velocity . y = JUMP_VELOCITY if PlayerState . position . x < position . x : velocity . x = - X_VELOCITY else : velocity . x = X_VELOCITY func set_movement_state (): if is_on_floor (): if movement_state == MovementState . AIRBORNE : # new line: velocity . x = 0 $ FloorBounceTimer . start () movement_state = MovementState . FLOOR_BOUNCE else : movement_state = MovementState . AIRBORNE Now press F5 and test: The first jump looks great, but the second jump already has an issue. So apparently, when the slime hits a wall, the velocity.x is set to zero by move_and_slide() ... Sounds like it makes perfect sense. But we want it to fly left to reach te player, so we're going to fight this resistance! :D. We'll pick our battle with physics right here: func handle_movement_state (): # keep trying to reach the player, even when bumping against the wall if is_on_wall (): if PlayerState . position . x < position . x : velocity . x = - X_VELOCITY else : velocity . x = X_VELOCITY pick_collision_shape_for_movement_state () pick_sprite_for_movement_state ()","title":"Using PlayerState.position in slime.gd"},{"location":"day-5/#refactor-early-part-2","text":"So I'm often a lone programmer, which is bad . One rule of thumb I learned concerning the DRY (Don't Repeat Yourself) principle I learned - when I did work in a team - is: if you see the same snippet of code duplicated 3 times, refactor. Well, I'm annoyed seeing it just 2 times right now, so let's fix it early : func follow_player (): if PlayerState . position . x < position . x : velocity . x = - X_VELOCITY else : velocity . x = X_VELOCITY Invoke it in handle_movement_state and start_jump. . Now your code is DRY again.","title":"Refactor early part 2"},{"location":"day-5/#make-the-slime-take-damage-from-fireballs","text":"When a fireball hits a slime we can detect it, but which of the two should detect the collision? Turns out we'll be handling this one, reasoning from the fireball. Which makes sense. The fireball will know how much punch it packs and it will deal it to anything that can take_damage(...) . So the first thing we will do is implement that method for the slime: @ export var hp = 10 func take_damage ( dmg : int ): hp -= dmg # test if it works print ( \"Ouch! hp = \" + str ( hp )) Now add the collision detection to the fireball like this: 1. Open res://projectiles/fireball/fireball.tscn 2. Select Scene > Fireball 3. Go to Node next to the Inspector tab 4. Double click Signals > Area2D > area_entered(...) 5. And connect it to the existing Fireball method _on_body_entered NOTE! that this is the first time I'm not saying \"pick the defaults in the dialog\" So first use pick : And then choose the _on_body_entered method: Adapt func _on_body_entered like so: @ export var damage = 1 func _on_body_entered ( body ): # if the body _can_ take damage, give it _my_damage if body . has_method ( \"take_damage\" ): body . take_damage ( damage ) # ... leave the rest ... So the var named body can be a slime and a slime will have the method take_damage . If it does, we invoke it! If not, it's not 'damageable' . Programmer's rant We call this duck-typing: \"If it looks like a duck and quacks like a duck...\" : if the target has a quack() method, we assume proactively it's a duck. In typed languages you need to declare an interface which tells the compiler (or interpreter) what methods the class implements. For a loosely typed scripting language like gdscript duck-typing makes more sense -- although inevitably you run into the request for type hints, like python did... anyway... whatever... you just want to make cool games, right? ...and if they crash, just ask a programmer! /Programmer's rant Test with F5 ! All sorts of stuff is not working as expected! Fireballs just mysteriously start dissipating Slimes are still not collided with by fireballs! So let's tackle both issues in reverse order :)","title":"Make the slime take damage from fireballs"},{"location":"day-5/#issue-2-slimes-are-not-in-the-correct-collission-layermask","text":"We forgot the collision layer and collision mask: Open res://monsters/slime/slime.tscn Go to Inspector > Collision Add the number 2 to the collision mask and -layer: That should fix it. The fireball should now dissipate upon hitting the slime and the slime should report its damage to the log:","title":"Issue #2: Slimes are not in the correct collission layer/mask"},{"location":"day-5/#fireballs-collide-into-eachother-now-and-dissipate","text":"So that mystery was solved quite quickly. Let's make sure that fireballs do not beat eachother anymore by deselecting collision layer 2 : Open res://projectiles/fireball/fireball.tscn Go to Inspector > Collision Deselect Layer > 2 : That should fix it:","title":"Fireballs collide into eachother now .. and dissipate"},{"location":"day-5/#allow-the-slime-to-die-from-damage","text":"The next step is not to allow that strange bit of negative hp ! All it takes is doing stuff we already did with the fireball: autoloaded texture renditions Open res://texture_renditions.gd Add the properties slime and slime_dissipate var slime = preload ( \"res://monsters/slime/green/5.png\" ) . get_image () var slime_dissipate : Array = [] And use get_dissipate_renditions to generate renditions for slime-death func _ready (): slime_dissipate = get_dissipate_renditions ( slime , 10 , 2 , 0.9 ) fireball_dissipate = get_dissipate_renditions ( fireball , 15 , 1 , 0.5 )","title":"Allow the slime to die from damage"},{"location":"day-5/#add-a-movementstate-and-animation-for-slime-death","text":"Next open the slime script to add the renditions. Open res://projectiles/fireball/fireball.gd Copy the rendition load code to your paste-buffer ( Ctrl + C ) # The sprite_frames of $AnimatedSprite2D is a singleton, so after calling # add_animation one time, it exists for all other instances if \"dissipate\" not in $ AnimatedSprite2D . sprite_frames . get_animation_names (): # Add a new animation to the SpriteFrames instance of the $AnimatedSprite2D node $ AnimatedSprite2D . sprite_frames . add_animation ( \"dissipate\" ) # Loop through all rendition images in the global singleton fireball_dissipate for rendition in TextureRenditions . fireball_dissipate : # Add them as a frame to $ AnimatedSprite2D . sprite_frames . add_frame ( \"dissipate\" , rendition ) Now open res://monsters/slime/slime.gd And paste the copied code into the _ready() function, adjusting one bit: .fireball_dissipate becomes .slime_dissipate if \"dissipate\" not in $ AnimatedSprite2D . sprite_frames . get_animation_names (): # Add a new animation to the SpriteFrames instance of the $AnimatedSprite2D node $ AnimatedSprite2D . sprite_frames . add_animation ( \"dissipate\" ) # Loop through all rendition images in the global singleton for rendition in TextureRenditions . slime_dissipate : # Add them as a frame to $ AnimatedSprite2D . sprite_frames . add_frame ( \"dissipate\" , rendition ) When the slime's hp is <= 0 then it should die Add the MovementState.DYING to the enum: enum MovementState { AIRBORNE , FLOOR_BOUNCE , DYING } So when the slime takes damage and drops below zero, set it: func take_damage ( dmg : int ): hp -= dmg if hp <= 0 : movement_state = MovementState . DYING Make sure it is not reset in set_movement_state() and disable collisions: func set_movement_state (): if movement_state == MovementState . DYING : # FIXME: move to pick_collision_shape_for_movement_state $ AirborneCollisionShape . disabled = true $ FloorBounceCollisionShape . disabled = true elif is_on_floor (): if movement_state == MovementState . AIRBORNE : velocity . x = 0 $ FloorBounceTimer . start () movement_state = MovementState . FLOOR_BOUNCE else : movement_state = MovementState . AIRBORNE And handle it in the movement_state handler: func handle_movement_state (): if movement_state == MovementState . DYING : velocity = Vector2 ( 0 , 0 ) # the rest was there already (behind 'el') elif is_on_wall (): follow_player () pick_collision_shape_for_movement_state () pick_sprite_for_movement_state () And make sure the correct animation for dying is picked: func pick_sprite_for_movement_state (): match ( movement_state ): MovementState . FLOOR_BOUNCE : $ AnimatedSprite2D . animation = \"floor_bounce\" MovementState . AIRBORNE : $ AnimatedSprite2D . animation = \"airborne\" MovementState . DYING : $ AnimatedSprite2D . animation = \"dissipate\"","title":"Add a MovementState and animation for slime death"},{"location":"day-5/#the-dissipate-timer","text":"Now let's add a DissipateTimer to the Slime scene Open res://monsters/slime/slime.tscn Go to Scene > Slime and add a child node Timer And rename it to DissipateTimer Make sure it is set to One Shot under Inspector , leave Wait Time to 1s Connect its timeout() -signal to slime.gd in the usual way (defaults in dialog and such) Implement as follows: func _on_dissipate_timer_timeout (): queue_free () And of course let's not forget to fire the timer when the slime has no hp left: func take_damage ( dmg : int ): hp -= dmg if hp <= 0 : movement_state = MovementState . DYING $ DissipateTimer . start () Test again and make sure the slime does stay dead...","title":"The dissipate timer"},{"location":"day-5/#make-the-slime-hurt-the-player-by-bouncing-into-the-player","text":"Being a CharacterBody2D , same as the Player is, the Slime does not have the body_entered , nor does it have area_entered out of the box. It is probably easier to just code collisions with the player more traditionally: in its movement handler using its get_slide_collision_* methods like documented in Detecting collisions : Open slime.gd Add a default damage as public property: @ export var damage = 1 Write a function damage_player : func damage_player (): # detect collisions based on collision count for i in get_slide_collision_count (): # get current colliding other thing var collider = get_slide_collision ( i ) . get_collider () # test if other thing is the Player # (collider could be null, so test existence first) if collider and collider . name == \"Player\" : # make the player take damage collider . take_damage ( damage ) Testing with F5 we soon run into an issue: the player does not yet have the take_damage method. Open player.gd Write the method take_damage : func take_damage ( damage : float ): print ( \"Ouch! I took: \" + str ( damage ) + \" damage!\" ) Test with F5 again and notice: she's taking a lot of damage: Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! Ouch! I took: 1 damage! So let's leave our player immortal for a while longer, because tweaking how fast she should die is pretty hard. We want to move on to bigger and better things for now. Just take a pass on her take_damage function for now so we don't clog up the log: func take_damage ( _damage ): # leave Zelia immortal for a while longer pass","title":"Make the slime hurt the player by bouncing into the player"},{"location":"day-5/#just-one-more-tweak-bounce-off-of-the-player","text":"One thing we should do now to finish the Slime behaviour is to allow it to bounce off of the player a little with the extra benefit that it won't collide into her that often. We can reuse its start_jump method for that: # test if other thing is the Player if collider . name == \"Player\" : # make the player take damage collider . take_damage ( damage ) # this is new start_jump () Testing again shows one more error: the slime double jumps! You can fix it by killing the FlourBounceTimer when a jump is started: func start_jump (): $ FloorBounceTimer . stop () velocity . y = JUMP_VELOCITY follow_player () That's a little much, maybe the slime should bounce off a bit less high: func start_jump ( init_velocity = JUMP_VELOCITY ): $ FloorBounceTimer . stop () velocity . y = init_velocity follow_player () Now in damage_player we can invoke it with a different init_velocity like: start_jump(-150) , still taking JUMP_VELOCITY as its default value.","title":"Just one more tweak: bounce off of the player"},{"location":"day-5/#add-the-tree-trunk-terrain","text":"Because Zelia (in the original game) runs into tiles that are not just squares, our rewrite must have them as well. Open res://world.tscn . Create a new Terrain in World > Inspector > Terrain Sets > Terrains : \"Tree Trunk\" Add the res://surface_maps/tree-trunk/1.png to our existing TileSet - like we learned on day 2 . Be sure to assign Terrain 1 this time, under the Select step When you get to the step for Physics with the F -hotkey we're going to do something new, but first... Don't forget to also create the 1 alternative tile (in case you want to handle all the drag-and-draw painting)","title":"Add the tree-trunk terrain"},{"location":"day-5/#create-polygons","text":"So textures in these tiles are not square at all! It would look pretty silly for Zelia to bump into free air. You can easily fix this by manipulating the physics -rect to become a polygon. Under Select > Physics > Physics Layer 0 there is an image with that rect drawn over it. Just click on the edges to add a new draggable vertex and manipulate that rect until it looks right: Next finish up the rest of the tree-trunk tiles until it looks like this:","title":"Create polygons"},{"location":"day-5/#dont-forget-to-draw-the-the-terrains-peering-bit-for-each-tile-using-the-tree-trunk-terrain-from-terrain-set-0","text":"So that bit should look like this:","title":"Don't forget to draw the the Terrains Peering Bit for each tile using the Tree Trunk terrain from Terrain Set 0"},{"location":"day-5/#draw-and-test","text":"Can Zelia now run up a slope? Why not try it out yourself.. Anyway, the place to test it out is in res://world.tscn and drawing this new terrain into the scene like we learned on day 2 :","title":"Draw and test!"},{"location":"day-5/#solve-technical-debt-3","text":"Now we want to achieve these next steps: 1. breakable tiles 2. tiles that fall down 3. tiles we can use as background scenery However, currently we only have one scene containing our TileMap and that scene is the TileMap . Which we renamed to World . That is a tight coupling between a TileMap and the entire rest of the game we foresaw technical debt on day 2 . What we need is that the main scene of our game has instances of our TileMap -scene: Create a new scene called Game that extends Node Save it into res://game.tscn Rename res://world.tscn to res://terrains.tscn Rename the scene name World to Terrains Delete all Terrains ' child nodes ( Player , Fireball - if still present, Slime s) Detach the world.gd -script by right clicking on the Terrains -node: Rename res://world.gd to res://game.gd Now open the game.tscn again and attach the game.gd script to it Make sure the script now extends Node in stead of TileMap : extends Node func _on_player_cast_projectile ( spell_class , direction , origin ): var spell = spell_class . instantiate () add_child ( spell ) spell . rotation = direction spell . position = origin spell . velocity = Vector2 . from_angle ( direction ) * 150.0 Attach the following scenes as children for Game by dragging them from the FileSystem tab: res://terrains.tscn res://player/player.tscn res://monsters/slime/slime.tscn Make res://game.tscn the main scene by right clicking it in the FileSystem tab Check the scene, which in my case looked like this: There is one thing: Zelia can't shoot anymore.","title":"Solve Technical debt 3"},{"location":"day-5/#fix-the-fireballs","text":"So we need to connect the cast_projectile -signal again to _on_player_cast_projectile (moved to game.gd ), like we did on day 4 : Select the Player -node (the child node of Game ) Go to Node > Signals Double click cast_projectile Select pick Double click on _on_player_cast_projectile(...) Click connect Test the game with F5","title":"Fix the fireballs"},{"location":"day-5/#make-tiles-zelia-can-break","text":"This next bit took quite some research and avenues attempted yet not taken. It might seem like the steps are evident and told as if they're easy (or even might have been done much better). They are, however, like many things, the result of effort, trial and error. That's why you just get the steps without the philosophies.","title":"Make tiles Zelia can break"},{"location":"day-5/#the-final-approach-in-very-simplified-terms","text":"Say a Terrains -instance is breakable using Metadata When the Terrains -instance is _ready() check if this breakable -field is true . If yes, loop through all the tiles in this instance For each tile, signal an event add_breakable_tile Let the game.gd script handle this signal .. .. by creating instances of a new scene called BreakableTile After the loop is done, invoke queue_free() to clear this Terrains -instance But first: preparations!","title":"The final approach in very simplified terms"},{"location":"day-5/#erase-the-tiles-in-the-terrains-scene","text":"First let's erase the tiles in the Terrains -scene. Open res://terrains.tscn . Click the Scene > Terrains -node Select TileMap in the bottom pane Select the Terrains -tab Pick on of the Terrains Select the eraser to erase the tiles Open res://game.tscn Now click the child node Terrains Navigate to TileMap > Terrains in the bottom pane again And draw some terrain in the Terrains - instance of the Game -scene","title":"Erase the tiles in the Terrains-scene"},{"location":"day-5/#adding-a-new-terrain-instance-to-game","text":"Now, without too many philosophies (as promised), thus further ado: Drag another instance of res://terrains.tscn into the Game scene It will be called Terrains2 if you did that right Rename it to BreakableTerrains Draw one tile while BreakableTerrains is active. Test if it is indeed in a the separate node by toggling its visibility:","title":"Adding a new Terrain-instance to Game"},{"location":"day-5/#adding-metadata-fields","text":"Now that we have a new instance of terrain in the game, we need to transmogrify it into breakable terrain. That means telling our code we intend to do that using metadata . Open res://terrains.tscn Navigate to the Inspector Scroll all the way down to find the + Add Metadata -button Click that button In the dialog give it the name breakable Keep the type as bool Click Add : Don't forget to save! Open res://game.tscn Click on BreakableTerrains Pop open the Inspector > Metadata And here check On the Breakable field: Also notice the revert arrow, which implies we overrode default behaviour","title":"Adding Metadata fields"},{"location":"day-5/#attach-a-new-terrainsgd-script","text":"Open res://terrains.tscn Click the -button Leave defaults active and click Create First let's check if our new Metadata -field works: extends TileMap func _ready (): if get_meta ( \"breakable\" ): print ( name + \" is breakable\" ) Test with F5 and observe: BreakableTerrains is breakable","title":"Attach a new terrains.gd script"},{"location":"day-5/#a-thorough-guide-to-the-poor-mans-debugger","text":"Now we will loop through the tiles and read all the properties we'll need to signal the game to create that BreakableTile -instance we announced before . All the godot methods and properties used are linked to their respective class-references: Loop through the tiles in our current (only) layer using get_used_cells func _ready (): if get_meta ( \"breakable\" ): print ( name + \" is breakable\" ) # Loop through the tile positions in our current (only) layer for cell in get_used_cells ( 0 ): print ( cell ) print ( cell * tile_set . tile_size ) Observe the log: BreakableTerrains is breakable (7, 2) (105, 30) The (7, 2) is the string serialization of a Vector2i , which represents the position of this tile on the TileMap 's grid. Our tile_set . tile_size is 15x15 so the position of the BreakableTile will become (105, 30) plus the position of this TileMap instance. Let's just print that TileMap -instance's position just to check: extends TileMap func _ready (): if get_meta ( \"breakable\" ): print ( name + \" is breakable\" ) print ( name + \"'s origin is: \" + str ( position )) # Loop through the tile positions in our current (only) layer for cell in get_used_cells ( 0 ): print ( \"Tile grid position: \" + str ( cell )) print ( \"BreakableTile target position: \" + str ( Vector2i ( position ) + cell * tile_set . tile_size )) Run with F5 and inspect the log: BreakableTerrains is breakable BreakableTerrains's origin is: (0, 0) Tile grid position: (7, 2) BreakableTile target position: (105, 30) Open res://game.tscn and select BreakableTerrains Change its position in Inspector > Transform > Position Rerun the game and inspect the log again: BreakableTile target position: (115, 41) Changed the BreakableTerrains ' position by +(10,11) as can be observed in the log Quickly revert the position to (0, 0) , which makes reasoning easier. Next use get_cell_source_id and tile_set . get_source to obtain the TileSetAtlasSource we used for our textures and physics polygons: for cell in get_used_cells ( 0 ): print ( \"Tile grid position: \" + str ( cell )) print ( \"BreakableTile target position: \" + str ( Vector2i ( position ) + cell * tile_set . tile_size )) var source_id = get_cell_source_id ( 0 , cell ) var tileset_source : TileSetAtlasSource = tile_set . get_source ( source_id ) print ( \"TileSetAtlasSource: \" + tileset_source . resource_name ) Test with F5 again: BreakableTerrains is breakable BreakableTerrains's origin is: (0, 0) Tile grid position: (7, 2) BreakableTile target position: (105, 30) TileSetAtlasSource: grass-and-dirt Next use our cell to obtain the position in the atlas texture of the current tile using get_cell_atlas_coords var tile_atlas_coords = get_cell_atlas_coords ( 0 , cell ) print ( \"tile_atlas_coords: \" + str ( tile_atlas_coords )) And of course, this also should be multiplied by our tile_set . tile_size to get the pixel position on the underlying texture. print ( \"tile_atlas_coords: \" + str ( tile_atlas_coords * tile_set . tile_size )) In order to clip out the correct image we need the Texture2D -resource of the atlas as well print ( \"texture: \" + tileset_source . texture . resource_path ) Just to be sure we're still on the same page, check your debug log again: BreakableTerrains is breakable BreakableTerrains's origin is: (0, 0) Tile grid position: (7, 2) BreakableTile target position: (105, 30) TileSetAtlasSource: grass-and-dirt tile_atlas_coords: (60, 15) texture: res://surface_maps/grass-and-dirt/1.png The last bit of information up next was the one that took me the longest: the collision polygons of this tile ( especially because I forgot to draw the polygon for the tile I was testing :D ). Also, the obstinate use of obtain umpten times is intentional : it's an achievement . Use the tile_atlas_coords we obtained with the tileset_source we obtained to obtain the tile_data of this tile with get_tile_data And then invoke get_collision_polygon_points to obtain the ... wait for it ... PackedVector2Array representing the collision polygon of this tile: var tile_data = tileset_source . get_tile_data ( tile_atlas_coords , 0 ) print ( \"polygon: \" + str ( tile_data . get_collision_polygon_points ( 0 , 0 ))) And that should look like this in your debug log: polygon: [(-7.5, -7.5), (7.5, -7.5), (7.5, 7.5), (-7.5, 7.5)] Now, just to make sure we did everything correctly ( did you also notice the 5 magic zeroes 0 we introduced, representing layers and layers and more layers of which we only seem to have one at each turn? ).. Let plant a tree with a divergent polygon as well (in our BreakableTerrains -instance of course): That should log something similar to this: Tile grid position: (9, 3) BreakableTile target position: (135, 45) TileSetAtlasSource: tree-trunk tile_atlas_coords: (75, 0) texture: res://surface_maps/tree-trunk/1.png polygon: [(-7.5, -7.5), (-6.125, -7.5), (-3.25, 0.125), (0.5, 4.5), (5.625, 5.75), (7.5, 7.5), (-7.5, 7.5)]","title":"A thorough guide to the poor man's debugger"},{"location":"day-5/#declaring-and-emitting-the-add_breakable_tile-signal","text":"Now that we've collected all the information we need for the game to spawn in one BreakableTile per tile in our BreakableTerrains -instance we're ready to us it. Declare the signal add_breakable_tile as follows in terrains.gd : signal add_breakable_tile ( position : Vector2i , texture : Texture2D , texture_pos : Vector2i , # collisigon is my personal shorthand for \"collision polygon\" collisigon : PackedVector2Array ) And emit it in the loop ( note we remove all the print s ): func _ready (): if get_meta ( \"breakable\" ): # Loop through the tile positions in our current (only) layer for cell in get_used_cells ( 0 ): var source_id = get_cell_source_id ( 0 , cell ) var tileset_source : TileSetAtlasSource = tile_set . get_source ( source_id ) var tile_atlas_coords = get_cell_atlas_coords ( 0 , cell ) var tile_data = tileset_source . get_tile_data ( tile_atlas_coords , 0 ) emit_signal ( \"add_breakable_tile\" , Vector2i ( position ) + cell * tile_set . tile_size , tileset_source . texture , tile_atlas_coords * tile_set . tile_size , tile_data . get_collision_polygon_points ( 0 , 0 ) ) Now in res://game.tscn select BreakableTerrains again Navigate to Node > Signals Double click add_breakable_tile Leave the defaults (so target is game.gd ) and click Connect Now print the inputs in this new listener: func _on_breakable_terrains_add_breakable_tile ( target_pos : Vector2 , texture : Texture2D , texture_pos : Vector2i , collisigon : PackedVector2Array ): print ( \"Target position of BreakableTile: \" + str ( target_pos )) print ( \"Atlas texture resource dir: \" + str ( texture . resource_path )) print ( \"Position of this tile in the atlas: \" + str ( texture_pos )) print ( \"Collision polygon of this tile: \" + str ( collisigon )) Go back to res://terrains.gd Earlier we announced in step 7 we would call queue_free after all the tiles in the map were signalled : func _ready (): if get_meta ( \"breakable\" ): # Loop through the tile positions in our current (only) layer # ... leave the for-loop in tact of course ... # Remove this TileMap from the parent scene queue_free () If you test again now, all we have left is the print messages in our console, but the (as yet) unbreakable tiles from the BreakableTerrains - TileMap are gone.","title":"Declaring and emitting the add_breakable_tile signal"},{"location":"day-5/#creating-the-breakabletile-scene","text":"Now in order the game.gd to instantiate breakable tiles and attach then as children we first need to make a BreakableTile -scene. It will be a bit of a weird scene, because we will be giving it empty child-nodes: - An empty Sprite2D .. - .. and an empty CollisionPolygon2D Create a new scene of type StaticBody2D In the scene tree rename its root node to BreakableTile Save the scene as res://tiles/breakable_tile.tscn Give it one child node of type Sprite2D And another child node of type CollisionPolygon2D It doesn't look like much in the - scene view, maybe temporarily we should add a texture for testing purposes: Create 15x15 pixel sized .png of any type you prefer (as long as it is visible !) Save that file into res://tiles/placeholder.png Select the BreakableTile > Sprite2D node Go to Inspector and select Texture > new ImageTexture Drag the placeholder.png into the select-box Now we can instantiate the scene with at the right position in the game.gd script: Open res://game.gd Use preload to import the BreakableTile -scene: var BreakableTile = preload ( \"res://tiles/breakable_tile.tscn\" ) Instatiate it in _on_breakable_terrains_add_breakable_tile And then use the position argument to set its position property func _on_breakable_terrains_add_breakable_tile ( target_pos : Vector2 , texture : Texture2D , texture_pos : Vector2i , collisigon : PackedVector2Array ): var new_tile : StaticBody2D = BreakableTile . instantiate () new_tile . position = target_pos This still does nothing visible. We need to add the BreakableTile -instance(s) to the game tree, which would make us see our rest://tiles/placholder.png -texture. HEADS UP! This next snippet won't work: func _on_breakable_terrains_add_breakable_tile ( target_pos : Vector2 , texture : Texture2D , texture_pos : Vector2i , collisigon : PackedVector2Array ): var new_tile : StaticBody2D = BreakableTile . instantiate () new_tile . position = target_pos # this is the code we want to execute add_child ( new_tile ) For the sake of learning, press F5 . So now we get this error in our console: game.gd:16 @ _on_breakable_terrains_add_breakable_tile(): Parent node is busy setting up children, `add_child()` failed. Consider using `add_child.call_deferred(child)` instead. That sounds super helpful! Let's try it out! func _on_breakable_terrains_add_breakable_tile ( target_pos : Vector2 , texture : Texture2D , texture_pos : Vector2i , collisigon : PackedVector2Array ): var new_tile : StaticBody2D = BreakableTile . instantiate () new_tile . position = target_pos add_child . call_deferred ( new_tile ) Test again with F5 and voil\u00e0, our pretty placeholder is added tot the scene:","title":"Creating the BreakableTile scene"},{"location":"day-5/#but-wait-whats-wrong-with-this-picture","text":"Exactly, the placement of our breakable tiles looks wrong, even though we correctly calculated their position. We need to fix the position of our Sprite2D and CollisionPolygon2D to match where the tile will be placed: Open res://tiles/breakable_tile.tscn in -scene view Select BreakableTile > Sprite2D Then set Inspector > Transform > Position to x=7.5 and y=7.5 Select BreakableTile > CollisionPolygon2D Also set Inspector > Transform > Position to x=7.5 and y=7.5 It should now look like this: Lesson learned : I'm not liking these 7.5 's I'm starting to see everywhere... I should have gone for 16x16 last year when I started drawing stuff based on my easy maths.","title":"But wait, what's wrong with this picture?"},{"location":"day-5/#setting-the-texture-and-collision-polygon-of-the-breakabletile","text":"The rest of the properties we prepared in game.gd we will pass on to properties for the BreakableTile itself to handle in its _ready -function. Open res://tiles/breakable_tile.tscn Select the root node BreakableTile Click the -button Leave the defaults and save into res://tiles/breakable_tile.gd Add these public properties: extends StaticBody2D @ export var texture : Texture2D @ export var texture_pos : Vector2i @ export var collisigon : PackedVector2Array func _ready (): print ( \"BreakableTile.position: \" + str ( position )) print ( \"BreakableTile.texture: \" + str ( texture . resource_path )) print ( \"BreakableTile.texture_pos: \" + str ( texture_pos )) print ( \"BreakableTile.collisigon: \" + str ( collisigon )) Open res://game.gd Set these new public properties in our signal listener: func _on_breakable_terrains_add_breakable_tile ( target_pos : Vector2 , texture : Texture2D , texture_pos : Vector2i , collisigon : PackedVector2Array ): var new_tile = BreakableTile . instantiate () new_tile . position = target_pos new_tile . texture = texture new_tile . texture_pos = texture_pos new_tile . collisigon = collisigon add_child . call_deferred ( new_tile ) Test this code again with F5 and confirm we're still seeing the same thing in our consoles: BreakableTile.position: (105, 30) BreakableTile.texture: res://surface_maps/grass-and-dirt/1.png BreakableTile.texture_pos: (60, 15) BreakableTile.collisigon: [(-7.5, -7.5), (7.5, -7.5), (7.5, 7.5), (-7.5, 7.5)] BreakableTile.position: (135, 45) BreakableTile.texture: res://surface_maps/tree-trunk/1.png BreakableTile.texture_pos: (75, 0) BreakableTile.collisigon: [(-7.5, -7.5), (-6.125, -7.5), (-3.25, 0.125), (0.5, 4.5), (5.625, 5.75), (7.5, 7.5), (-7.5, 7.5)] Now let's set the correct texture, texture position and polygon in code: func _ready (): $ Sprite2D . set_texture ( texture ) $ Sprite2D . region_rect = Rect2 ( texture_pos . x , texture_pos . y , 15 , 15 ) $ CollisionPolygon2D . polygon = collisigon Testing with F5 you'll probably get this, like me (the entire atlas as a texture): That is because you need to enable the region_rect feature we used. You can either do this in code or in the BreakableTile -inspector. 1. in code: $Sprite2D.region_enabled = true 2. in the scene select the Sprite2D -child node: check Inspector > Region > Enabled to On It's really up to you which you choose, but this tutorial has used the configuration over code approach so far, which implies the 2nd choice... (Usually, as a programmer, I prefer code as configuration, keeping everything nice and together, in stead of in separate places).","title":"Setting the texture and collision polygon of the BreakableTile"},{"location":"day-5/#fix-the-collision-layer-and-mask","text":"One last thing you'll have noticed by now is that the collision layer and -mask are not the same for our BreakableTile as for our Terrains scene. That explains fireballs flying right through them. Let's make them match. Open res://tiles/breakable_tile.tscn Go to Inspector > Collision For Layer check both 1 and 2 And for Mask check both 1 and 2 as well","title":"Fix the collision layer and -mask"},{"location":"day-5/#make-them-break","text":"Finally ! Up till now we only made a copy of some tiles as a StaticBody2D , which made them behave the same as the TileMap . However, now we can use fireball-collisions to reduce some HP -property and let the tiles disappear when they're out of HP . Here we will use a 2-step approach: 1. Give the breakable tiles an HP property, reduce it on 'take_damage', make them queue_free 2. Generate 'cracked' renditions of the terrain textures to show the user the damage","title":"Make them break!!"},{"location":"day-5/#remove-tiles-that-are-broken","text":"We made things that can take damage implement the take_damage -function. That way, things that give damage have a place to invoke that damage. Like our fireballs. Let's see if we can achieve that effect right now 1. Open res://tiles/breakable_tile.gd 2. Implement take_damage() like this: func take_damage ( dmg : float ): print ( \"Breakable tile taking \" + str ( dmg ) + \" damage\" ) Then press F5 and shoot some fireballs at it. Check the console if we're still seeing the same things: Breakable tile taking 1 damage Breakable tile taking 1 damage Breakable tile taking 1 damage Yup! That works. Now let's add a public property called hp which we can set from metadata later. Add the hp property on top of breakable_tile.gd and set it to 10 as a default. extends StaticBody2D @ export var hp : float = 10.0 @ export var texture : Texture2D @ export var texture_pos : Vector2i @ export var collisigon : PackedVector2Array Implement take_damage like this now: func take_damage ( dmg : float ): hp -= dmg if hp <= 0 : queue_free () Then press F5 and shoot some fireballs at it again . Watch with satisfaction as these tiles disappear after only 10 hits with a fireball:","title":"Remove tiles that are broken"},{"location":"day-5/#hp-as-metadata","text":"As a level editor you want control over the amount HP a breakable tile gets. We can achieve this by adding another metadata field to our Terrains - Tilemap scene called.. Hp . Let's do that now: Open res://terrains.tscn and select the Terrains root node Go to Inspector > Metadata > + Add Metadata Set the Name to hp and the type to float or int (your quacking choice) Click Add Set the value to 10 to serve as the default value Now open res://terrains.gd Add hp as a 5th parameter to add_breakable_tile signal add_breakable_tile ( position : Vector2i , texture : Texture2D , texture_pos : Vector2i , collisigon : PackedVector2Array , hp : float ) Add the hp -metadata to the emit_signal -call for each tile: emit_signal ( \"add_breakable_tile\" , Vector2i ( position ) + cell * tile_set . tile_size , tileset_source . texture , tile_atlas_coords * tile_set . tile_size , tile_data . get_collision_polygon_points ( 0 , 0 ), get_meta ( \"hp\" ) ) Open res://game.gd Add the hp to _on_breakable_terrains_add_breakable_tile and set it on the BreakableTile instance there: func _on_breakable_terrains_add_breakable_tile ( target_pos : Vector2 , texture : Texture2D , texture_pos : Vector2i , collisigon : PackedVector2Array , hp : float ): var new_tile = BreakableTile . instantiate () new_tile . position = target_pos new_tile . texture = texture new_tile . texture_pos = texture_pos new_tile . collisigon = collisigon new_tile . hp = hp add_child . call_deferred ( new_tile ) To test, see how it works when you change hp metadata in the BreakableTerrains tilemap of your game.","title":"HP as metadata"},{"location":"day-5/#generate-some-pretty-cracks-to-show-the-tile-damage","text":"What is missing is some visual feedback of tiles breaking. For that effect, we will revisit our approach to renditions , like we did with the dissipating fireballs . This time we will use a set of .png files as an alpha mask. You can download them from here: Download cracked-renditions.zip Extract cracked-renditions.zip in res://surface_maps Open res://texture_rendition.gd Preload the files as an image resource like this: var crack_mask_0 = preload ( \"res://surface_maps/crack-mask-0.png\" ) . get_image () var crack_mask_1 = preload ( \"res://surface_maps/crack-mask-1.png\" ) . get_image () var crack_mask_2 = preload ( \"res://surface_maps/crack-mask-2.png\" ) . get_image () var crack_mask_3 = preload ( \"res://surface_maps/crack-mask-3.png\" ) . get_image () And prepare these 2 data objects to be used in our rendition code: var crack_masks = [ crack_mask_0 , crack_mask_1 , crack_mask_2 , crack_mask_3 ] var cracked_rendition_map : Dictionary = {} The first function we'll write is a reusable function get_alpha_mask_rendition , which takes 2 arguments src_image : Image , the image we want to make partly transparent using an alpha mask alpha_map : Image , the image we will use to 'draw transparency' on the source image, as it were func get_alpha_mask_rendition ( src_image : Image , alpha_map : Image ): # create a destination image with the same properties as the source image var dst_rendition = Image . create ( src_image . get_width (), src_image . get_height (), false , src_image . get_format ()) # loop through all the pixels in the source image for x in range ( src_image . get_width ()): for y in range ( src_image . get_height ()): # Get the original color var src_color = src_image . get_pixel ( x , y ) # Get the color representing the amount of transparency to draw var alpha_color = alpha_map . get_pixel ( x , y ) # Calculate how much transparency this should be, by inverting # the alpha-amount of the mask's color var dest_alpha = 1.0 - alpha_color . a if 1.0 - alpha_color . a > 0.0 else 0.0 # draw a pixel to the destination image based on the source pixel # and set the alpha to the lowest of these 2 alpha values: # 1. dest_alpha # 2. the alpha of the source pixel dst_rendition . set_pixel ( x , y , Color ( src_color . r , src_color . g , src_color . b , min ( src_color . a , dest_alpha ))) # return the destination image as an ImageTexture object return ImageTexture . create_from_image ( dst_rendition ) Let's then write a function get_cracked_renditions which takes 2 arguments source_id : int , a key for our dictionary to make sure the rendition is generated only once in code (singleton pattern) src_image : Image the image we want to generate cracked renditions for func get_cracked_renditions ( source_id : int , src_image : Image ): if source_id in cracked_rendition_map : return cracked_rendition_map [ source_id ] print ( \"Assert single invocation for get_cracked_renditions:\" + str ( source_id )) # copy the source image into the rendition map cracked_rendition_map [ source_id ] = [ ImageTexture . create_from_image ( src_image )] # for each alpha mask we preloaded into the crack_masks array ... for crack_mask in crack_masks : # ... make a rendition with get_alpha_mask_rendition and add it to # the dictionary using source_id as key cracked_rendition_map [ source_id ] . append ( get_alpha_mask_rendition ( src_image , crack_mask )) # of course return the dictionary return cracked_rendition_map [ source_id ]","title":"Generate some pretty cracks to show the tile damage"},{"location":"day-5/#allow-those-breakable-tiles-to-fall-down","text":"Rigid -> Static -> Rigid -> Character -> Area -> Static -> Rigid -> ooooh... Spoiler: it was StaticBody2D I wanted all along.","title":"Allow those breakable tiles to fall down"},{"location":"day-5/#technical-debt-6","text":"While following the my first 3D game tutorial I was reminded of Godot's group tagging feature in part 06. on squashing monsters : Group tagging in Godot Both our BreakableTile s and our Slimes should be tagged as part of some group in order for us to better determine what to do when a collision takes place with them.","title":"Technical debt 6"},{"location":"day-5/#reuse-tiles-as-background-scenery","text":"The original Zelia game used a simple trick for background textures: add a little transparency to the terrain maps and draw them behind the rest of the game. Although we could probably do this without any complexity, let's use this oppurtunity to explore 2D fragment shaders.","title":"Reuse tiles as background scenery"}]}